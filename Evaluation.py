# -*- coding: utf-8 -*-
"""Final Code.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1OVhK4lVjKtPwJTBXjL5MGk9szFgm0C8G
"""



"""# GSDMM Code for Text Analysis

# 1) Importing Libraries

Installing needed Libraries  and import all libraries which will be used in the code
"""

InstallFastText = False

if InstallFastText : 
  !pip install fasttext

pip install git+https://github.com/rwalk/gsdmm.git

if InstallFastText : 
  import fasttext.util
  fasttext.util.download_model('en', if_exists='ignore') 
  EnglishWE = fasttext.load_model('/content/cc.en.300.bin')

# Commented out IPython magic to ensure Python compatibility.
import numpy as np 
import pandas as pd
from gsdmm import MovieGroupProcess
from gensim.models.coherencemodel import CoherenceModel
from gensim import corpora, models
from gensim.utils import simple_preprocess
import gensim, spacy,re,os,nltk,random
from gensim.models.ldamulticore import LdaMulticore
from gensim.test.utils import common_corpus, common_dictionary
from gensim.models.coherencemodel import CoherenceModel
from gensim.models import Phrases
from gensim.models.phrases import Phraser
! python -m spacy download en_core_web_sm
from nltk.corpus import stopwords
from tqdm import tqdm 
from wordcloud import WordCloud
nltk.download('stopwords')
nlp = spacy.load('en_core_web_sm', disable=['parser', 'ner'])
import matplotlib.pyplot as plt
from tabulate import tabulate
# %matplotlib inline

import warnings,os,csv, nltk,spacy,re
from warnings import filterwarnings
filterwarnings('ignore')

nltk.download('punkt')
from nltk.tokenize import word_tokenize
regex = re.compile('[^a-zA-Z]')
nltk.download('stopwords')
from nltk.corpus import stopwords
StopWords = stopwords.words('english')
nlp = spacy.load('en_core_web_sm')

"""# 2) Data Cleansing"""

# import pandas as pd
# import os,re
# from tqdm import tqdm

"""Check HTML"""

DataCleaning = False
if DataCleaning: 
  MainPath = r'/content/drive/MyDrive/Data/PhD/Week 24 All Data'
  DataFiles = os.listdir(os.path.join(MainPath,'0 Data'))
  DataFiles = [i for i in DataFiles if i[0]!='_']
  HTMLWords = []
  for File in tqdm(DataFiles) : 
    data = pd.read_csv(os.path.join(MainPath ,'0 Data',File))
    ColName = {'BTBusiness.csv':'Description','Vodafone Final Reviews.csv':'reviewBody','Orange TrustPilot Reviews.csv':'reviewBody','BT TrustPilot Reviews.csv':'reviewBody',
              'BT Forums Community.csv':'Description','VirginMedia TrustPilot Reviews.csv':'reviewBody'}
    ThisCol = ColName[str(File).replace('Cleaned_','')]
    HTMLWords.extend( [ re.findall(r'<.*?>', str(i)) for i in data[ThisCol].tolist()])
  HTMLWords= [i for i in HTMLWords if len(i)>0]
  print(f'\nNumber of HTML Words : {len(HTMLWords)}')

"""Check <> existence"""

if DataCleaning: 
  HTMLWords = []
  for File in tqdm(DataFiles) : 
    data = pd.read_csv(os.path.join(MainPath ,'0 Data',File))
    ColName = {'BTBusiness.csv':'Description','Vodafone Final Reviews.csv':'reviewBody','Orange TrustPilot Reviews.csv':'reviewBody','BT TrustPilot Reviews.csv':'reviewBody',
              'BT Forums Community.csv':'Description','VirginMedia TrustPilot Reviews.csv':'reviewBody'}
    ThisCol = ColName[str(File).replace('Cleaned_','')]
    HTMLWords.extend([i for i in data[ThisCol].tolist() if '<' in str(i)])
    HTMLWords.extend([i for i in data[ThisCol].tolist() if '>' in str(i)])
  print(f'\nHTML Words : {HTMLWords}')

"""Word TR"""

if DataCleaning: 
  MainPath = r'/content/drive/MyDrive/Data/PhD/Week 24 All Data'
  DataFiles = os.listdir(os.path.join(MainPath,'0 Data'))
  DataFiles = [i for i in DataFiles if i[0]=='C']
  HTMLWords = []
  for File in DataFiles : 
    data = pd.read_csv(os.path.join(MainPath ,'0 Data',File))
    ColName = {'BTBusiness.csv':'Description','Vodafone Final Reviews.csv':'reviewBody','Orange TrustPilot Reviews.csv':'reviewBody','BT TrustPilot Reviews.csv':'reviewBody',
              'BT Forums Community.csv':'Description','VirginMedia TrustPilot Reviews.csv':'reviewBody'}
    ThisCol = ColName[str(File).replace('Cleaned_','')]
    print(File)
    AllText = ' '.join([str(i) for i in data['CleanedText'].tolist()])
    TR = [i for i in AllText.split() if i.lower().strip() == 'tr' ]
    print(TR)
    print('----------------------------------')



"""write SW in Latex Format"""

if DataCleaning : 
  CustomizedStopWords =  ['i', 'me', 'my', 'myself', 'we', 'our', 'ours', 'ourselves', 'you', "you're", "you've", "you'll", "you'd", 'your', 'yours', 'yourself', 'yourselves', 'he', 'him', 'his', 'himself', 'she', "she's", 'her', 'hers', 'herself',
                        'it', "it's", 'its', 'itself', 'they', 'them', 'their', 'theirs', 'themselves', 'what', 'which', 'who', 'whom', 'this', 'that', "that'll", 'these', 'those', 'am', 'is', 'are', 'was', 'were', 'be', 'been', 'being', 'have',
                        'has', 'had', 'having', 'do', 'does', 'did', 'doing', 'a', 'an', 'the', 'and', 'but', 'if', 'or', 'because', 'as', 'until', 'while', 'of', 'at', 'by', 'for', 'with', 'about', 'between', 'into', 'through','to', 'from', 'in',
                        'on', 'off', 'again', 'further', 'then', 'once', 'here', 'there', 'when', 'where', 'why', 'how', 'all', 'any', 'both', 'each', 'other', 'some', 'such','only', 'own', 'same', 'so', 'than', 'too', 'very', 's', 't', 'can',
                        'will', 'just', 'don', "don't", 'should', "should've"]
  RemovedWords = ['&amp','amp','lia','li','ul','ol','blockquote','strong','table','font','image','someone','anyone','everyone','hello','hi','morning','can','use','evening','bye','b','em','mark','small','del','ins','sub','sup','tr']

  A = []
  A.extend(CustomizedStopWords)
  A.extend(RemovedWords)
  len(A)
  for k in range(0,150,10) : 
    print(' & '.join([i for i in A[k:k+10]]) + str(''))

"""Data Cleaning"""

if DataCleaning: 
  CustomizedStopWords =  ['i', 'me', 'my', 'myself', 'we', 'our', 'ours', 'ourselves', 'you', "you're", "you've", "you'll", "you'd", 'your', 'yours', 'yourself', 'yourselves', 'he', 'him', 'his', 'himself', 'she', "she's", 'her', 'hers', 'herself',
                        'it', "it's", 'its', 'itself', 'they', 'them', 'their', 'theirs', 'themselves', 'what', 'which', 'who', 'whom', 'this', 'that', "that'll", 'these', 'those', 'am', 'is', 'are', 'was', 'were', 'be', 'been', 'being', 'have',
                        'has', 'had', 'having', 'do', 'does', 'did', 'doing', 'a', 'an', 'the', 'and', 'but', 'if', 'or', 'because', 'as', 'until', 'while', 'of', 'at', 'by', 'for', 'with', 'about', 'between', 'into', 'through','to', 'from', 'in',
                        'on', 'off', 'again', 'further', 'then', 'once', 'here', 'there', 'when', 'where', 'why', 'how', 'all', 'any', 'both', 'each', 'other', 'some', 'such','only', 'own', 'same', 'so', 'than', 'too', 'very', 's', 't', 'can',
                        'will', 'just', 'don', "don't", 'should', "should've"]
  RemovedWords = ['&amp','amp','lia','li','ul','ol','blockquote','strong','table','font','image','someone','anyone','everyone','hello','hi','morning','can','use','evening','bye','b','em','mark','small','del','ins','sub','sup','tr']
  CustomizedStopWords.extend(RemovedWords)

  MainPath = r'/content/drive/MyDrive/Data/PhD/Week 24 All Data'
  AllWordsWEDF = pd.read_csv(os.path.join(MainPath ,'0 Data','_AllWordsWE.csv'))
  EnglishWE = pd.read_csv(os.path.join(MainPath ,'0 Data','_EnglishWE.csv'))
  DataFiles = os.listdir(os.path.join(MainPath,'0 Data'))
  DataFiles = [i for i in DataFiles if i[0]!='_']
  print(len(DataFiles))

  ValidEnglishWords = EnglishWE['Word'].tolist()
  print(len(ValidEnglishWords))
  print(AllWordsWEDF.shape,EnglishWE.shape)
  ##############################################################
  WordDict = {}
  for File in tqdm(DataFiles) : 
    data = pd.read_csv(os.path.join(MainPath ,'0 Data',File))
    ColName = {'BTBusiness.csv':'Description','Vodafone Final Reviews.csv':'reviewBody','Orange TrustPilot Reviews.csv':'reviewBody','BT TrustPilot Reviews.csv':'reviewBody',
              'BT Forums Community.csv':'Description','VirginMedia TrustPilot Reviews.csv':'reviewBody'}
    ThisCol = ColName[str(File).replace('Cleaned_','')]
    ThisFileWords = ' '.join([str(i).lower().strip() for i in data[ThisCol].tolist()])
    ThisFileWords = [re.sub('[^A-Za-z0-9]+', '',i) for i in ThisFileWords.split()]
    
    OriginalWords = list(set(ThisFileWords))
    AllTextSet = list(set(ThisFileWords) & set(ValidEnglishWords))
    RemovedWords = [i for i in OriginalWords if not i in AllTextSet]
    WordDict[File.split('.')[0]] = {'OriginalWords': OriginalWords,'CleanedWords' : AllTextSet,'RemovedWords' : RemovedWords}


  AllLists = []
  Columns = []
  AllRemovedWords = []
  for k,v in WordDict.items() : 
    AllRemovedWords.extend(v['RemovedWords'])
    for i,j in v.items() : 
      Columns.append(f'{k}_{i}')
      j.insert(0,len(j))
      AllLists.append(j)

  print(len(AllRemovedWords))  
  AllRemovedWords = list(set(AllRemovedWords))
  print(len(AllRemovedWords))  
  AllRemovedWords.insert(0,len(AllRemovedWords))
  Columns.append('AllRemovedWords')
  AllLists.append(AllRemovedWords)
  WordsDF = pd.DataFrame(AllLists,index= Columns).T
  WordsDF.to_csv(os.path.join(MainPath ,'0 Data',f'_WordsStatistics.csv'))    

  ##############################################################
  def DataCleaning(x,AllTextSet) : 
    x = ' '.join([str(i).lower().strip() for i in str(x).split()])
    x = ' '.join([i for i in x.split() if i in AllTextSet])
    return x
  for File in tqdm(DataFiles) : 
    data = pd.read_csv(os.path.join(MainPath ,'0 Data',File))
    ColName = {'BTBusiness.csv':'Description','Vodafone Final Reviews.csv':'reviewBody','Orange TrustPilot Reviews.csv':'reviewBody','BT TrustPilot Reviews.csv':'reviewBody',
              'BT Forums Community.csv':'Description','VirginMedia TrustPilot Reviews.csv':'reviewBody'}
    ThisCol = ColName[str(File).replace('Cleaned_','')]
    ThisFileWords = ' '.join([str(i).lower() for i in data[ThisCol].tolist()])
    AllTextSet = list(set(ThisFileWords.split()) & set(ValidEnglishWords))
    AllTextSet = [str(i) for i in AllTextSet if not i in RemovedWords]
    AllTextSet = [i for i in AllTextSet if not i in CustomizedStopWords]
    AllTextSet = [i for i in AllTextSet if  i.isalpha()]
    AllTextSet = [i for i in AllTextSet if  len(i) >1]
    
    data['CleanedText'] = data[ThisCol].apply(lambda x : DataCleaning(x,AllTextSet))
    data.to_csv(os.path.join(MainPath ,'0 Data',f'Cleaned_{File}'))

"""Data Cleaning Statistics Table"""

DataCleaning = True
import pandas as pd
import os
import  numpy as np

if DataCleaning: 
  Path = '/content/drive/MyDrive/Data/PhD/Week 24 All Data/0 Data'
  Files = [i for i in os.listdir(Path) if i[:7] == 'Cleaned']

  ColName = {'BTBusiness.csv':'Description','Vodafone Final Reviews.csv':'reviewBody','Orange TrustPilot Reviews.csv':'reviewBody','BT TrustPilot Reviews.csv':'reviewBody',
            'BT Forums Community.csv':'Description','VirginMedia TrustPilot Reviews.csv':'reviewBody'}
  for j in range(1,6) : 
    SmallPhrases = {}
    for File in Files : 
      print(f'For file {File}')
      data = pd.read_csv(os.path.join(Path,File))
      FileName = str(File).replace('Cleaned_','')
      WordLengthBefore = [len(str(i).split()) for i in data[ColName[FileName]].tolist()]
      WordLengthAfter = [len(str(i).split()) for i in data['CleanedText'].tolist()]
      print(f'Before : Mean {np.mean(WordLengthBefore)} ,Min {np.min(WordLengthBefore)} ,Max {np.max(WordLengthBefore)} ,SD {np.std(WordLengthBefore)}  ')
      print(f'After : Mean {np.mean(WordLengthAfter)} ,Min {np.min(WordLengthAfter)} ,Max {np.max(WordLengthAfter)} ,SD {np.std(WordLengthAfter)} \n ')
      print('-------------------------------------------------------------')
      SmallPhrases[f'{FileName} BeforeCleaning'] = [str(i) for i in data[ColName[FileName]].tolist() if len(str(i).split()) <= j]
      SmallPhrases[f'{FileName} AfterCleaning'] = [str(i) for i in data['CleanedText'].tolist() if len(str(i).split()) <= j]
    pd.concat([pd.DataFrame([len(i) for i in SmallPhrases.values()],index=list(SmallPhrases.keys())).T,pd.DataFrame(list(SmallPhrases.values()),index=list(SmallPhrases.keys())).T],axis=0).to_csv(os.path.join(Path,f'_SmallWords_{j}.csv'))

"""Check if one-word sentence"""

if DataCleaning: 
  Path = '/content/drive/MyDrive/Data/PhD/Week 24 All Data/0 Data'
  Files = [i for i in os.listdir(Path) if i[:7] == 'Cleaned']

  ColName = {'BTBusiness.csv':'Description','Vodafone Final Reviews.csv':'reviewBody','Orange TrustPilot Reviews.csv':'reviewBody','BT TrustPilot Reviews.csv':'reviewBody',
            'BT Forums Community.csv':'Description','VirginMedia TrustPilot Reviews.csv':'reviewBody'}

  for File in Files : 
    data = pd.read_csv(os.path.join(Path,File))
    OriginalShape =  data.shape[0]
    data['WordLength'] = data['CleanedText'].apply(lambda x : len(str(x).split()))
    data = data[data['WordLength']>1]
    print(f'for {File}  Dropped : {OriginalShape - data.shape[0]} rows')
    data.reset_index(inplace=True)
    data.to_csv(os.path.join(Path,File))
# for Cleaned_Vodafone Final Reviews.csv  Dropped : 4 rows
# for Cleaned_BT TrustPilot Reviews.csv  Dropped : 7 rows
# for Cleaned_VirginMedia TrustPilot Reviews.csv  Dropped : 20 rows
# for Cleaned_BT Forums Community.csv  Dropped : 8 rows
# for Cleaned_Orange TrustPilot Reviews.csv  Dropped : 134 rows
# for Cleaned_BTBusiness.csv  Dropped : 4 rows

if DataCleaning: 
  Path = '/content/drive/MyDrive/Data/PhD/Week 24 All Data/0 Data'
  Files = [i for i in os.listdir(Path) if i[:7] == 'Cleaned']

  ColName = {'BTBusiness.csv':'Description','Vodafone Final Reviews.csv':'reviewBody','Orange TrustPilot Reviews.csv':'reviewBody','BT TrustPilot Reviews.csv':'reviewBody',
            'BT Forums Community.csv':'Description','VirginMedia TrustPilot Reviews.csv':'reviewBody'}

  for File in Files : 
    data = pd.read_csv(os.path.join(Path,File))
    OriginalShape =  data.shape[0]
    data['WordLength'] = data['CleanedText'].apply(lambda x : len(str(x).split()))
    data = data[data['WordLength']>1]
    print(f'for {File}  Dropped : {OriginalShape - data.shape[0]} rows')
    data.reset_index(inplace=True)
    data.to_csv(os.path.join(Path,File))


# for Cleaned_Vodafone Final Reviews.csv  Dropped : 0 rows
# for Cleaned_BT TrustPilot Reviews.csv  Dropped : 0 rows
# for Cleaned_VirginMedia TrustPilot Reviews.csv  Dropped : 0 rows
# for Cleaned_BT Forums Community.csv  Dropped : 0 rows
# for Cleaned_Orange TrustPilot Reviews.csv  Dropped : 0 rows
# for Cleaned_BTBusiness.csv  Dropped : 0 rows

"""# 3) Defining Functions"""

# Gensims Functions
# all gensim functions which used to generate GSDMMM topic modeling
def sent_to_words(sentences):
    for sentence in sentences:
        yield(gensim.utils.simple_preprocess(str(sentence), deacc=True))
def make_n_grams(texts):
    bigram = gensim.models.Phrases(texts, min_count=5, threshold=100)  
    bigram_mod = gensim.models.phrases.Phraser(bigram)
    trigram = gensim.models.Phrases(bigram[texts], threshold=100)
    trigram_mod = gensim.models.phrases.Phraser(trigram)
    bigrams_text = [bigram_mod[doc] for doc in texts]
    trigrams_text =  [trigram_mod[bigram_mod[doc]] for doc in bigrams_text]
    return trigrams_text      

def remove_stopwords(texts):
    return [[word for word in simple_preprocess(str(doc)) if word not in gensim.parsing.preprocessing.STOPWORDS] for doc in texts]

def lemmatization(texts, allowed_postags=['NOUN', 'ADJ', 'VERB', 'ADV']):
    texts_out = []
    for sent in texts:
        doc = nlp(" ".join(sent)) 
        texts_out.append([token.lemma_ for token in doc if token.pos_ in allowed_postags])
    return texts_out      
def top_words(mgp,cluster_word_distribution, top_cluster, values):
  Text = ''
  TheseResults = []
  for cluster in top_cluster:
    sort_dicts =sorted(mgp.cluster_word_distribution[cluster].items(), key=lambda k: k[1], reverse=True)[:values]
    Text+= "\nCluster %s : %s"%(cluster,sort_dicts)
    TheseResults.append([cluster,sort_dicts])
  return Text,TheseResults

def WordDifference(Word1,Word2) :
  global SavedWords
  Word1,Word2 = Word1.lower(),Word2.lower()
  if not  Word1 in SavedWords.keys() or not  Word2 in SavedWords.keys() : print('Word not found')
  ThisResult = np.linalg.norm(np.array(SavedWords[Word1])-np.array(SavedWords[Word2]), ord = 2) 
  return ThisResult

# Cleaning Clusters
# clean data before processed by topic modeling
def ClusterClean(x) : 
  if ',' in str(x) : 
    List = [re.sub('[^A-Za-z0-9,]+', '', i).split(',')  for i in x.split('),')]
    List = [[i[0],int(i[1])] for i in List]
    # List = [i  for i in x.split('),')]
    ThisList = []
    for l in range(0,len(List),2) : 
      if l < len(List)-1 : 
        ThisList.append((List[l],List[l+1]))

    return List
  else :
    return x

# Applying GSDMM
# applying gsdmm model through several steps
MainPath,SelectedData = None,None
def ApplyGSDMM(K): 
  global MainPath,SelectedData
  if  os.path.exists(os.path.join(MainPath,SelectedData,'01 GSDMMFiles',f'Clusters Number {K}.csv')) :
     print(f'Cluster {K} Exists')
     return None
  print(f'Applying for Cluster {K}')
  tokens_reviews = list(sent_to_words(data['CleanedText']))
  tokens_reviews = make_n_grams(tokens_reviews)
  reviews_lemmatized = lemmatization(tokens_reviews, allowed_postags=['NOUN', 'VERB', 'ADV'])
  reviews_lemmatized = remove_stopwords(reviews_lemmatized)
  print(reviews_lemmatized)
  np.random.seed(0)
  Results =[]
  X = 0
  
  for Alpha in list(np.linspace(0.05,1,20)) :  # using different values for alpha
    for Beta in list(np.linspace(0.05,1,20)) : # using different values for beta
      X+=1
      print(f'Phase Number {X}')
      mgp = MovieGroupProcess(K=K, alpha=Alpha, beta=Beta, n_iters=30)
      vocab = set(x for review in reviews_lemmatized for x in review)
      n_terms = len(vocab)
      model = mgp.fit(reviews_lemmatized, n_terms)
      doc_count = np.array(mgp.cluster_doc_count)
      top_index = doc_count.argsort()[-10:][::-1]
      Loss =0
      for i in range(K) : 
        Loss += abs((1/K)-(doc_count[i]/sum(doc_count)))
      Results.append({'Parameters' : [Alpha,Beta],
                      'Loss':Loss,
                      'Doc Number':doc_count,
                      'Top Index':doc_count.argsort()[-10:][::-1],
                      'Top Words' : top_words(mgp,mgp.cluster_word_distribution, top_index, 10)[0],
                      'All Words' : top_words(mgp,mgp.cluster_word_distribution, top_index, 100)[1]})
  
  
  ResultsDF = pd.DataFrame(columns = ['Parameters', 'Loss', 'Doc Number', 'Top Index', 'Top Words', 'All Words'])
  for n,i in enumerate(Results) : 
    ResultsDF.loc[n] = list(i.values())
  ResultsDF  
  TotalCluster = [f'Cluster {i}' for i in range(K)]
  for j in TotalCluster : 
    ResultsDF[j] =ResultsDF['Top Words'].apply(lambda x : [i for i in str(x.strip('\n')).split('\n') if j in i][0].strip(f'{j} : ').strip('[]'))
  
  for j in range(K) : 
    ResultsDF[f'All Cluster {j}'] = ResultsDF['All Words'].apply(lambda x : [i[1] for i in x if i[0]==j])
  if not os.path.exists(os.path.join(MainPath,SelectedData,'01 GSDMMFiles')) :  os.makedirs(os.path.join(MainPath,SelectedData,'01 GSDMMFiles'))
  ResultsDF.to_csv(os.path.join(MainPath,SelectedData,'01 GSDMMFiles',f'Clusters Number {K}.csv'))  # saving in 01 folder
  return Results

"""BCV :  Euclidean Equation


![001.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZsAAAEjCAYAAADkAazgAAAAAXNSR0IArs4c6QAABhJ0RVh0bXhmaWxlACUzQ214ZmlsZSUyMGhvc3QlM0QlMjJhcHAuZGlhZ3JhbXMubmV0JTIyJTIwbW9kaWZpZWQlM0QlMjIyMDIyLTEwLTEwVDEwJTNBMDElM0E0NC45NDZaJTIyJTIwYWdlbnQlM0QlMjI1LjAlMjAoV2luZG93cyUyME5UJTIwMTAuMCUzQiUyMFdpbjY0JTNCJTIweDY0KSUyMEFwcGxlV2ViS2l0JTJGNTM3LjM2JTIwKEtIVE1MJTJDJTIwbGlrZSUyMEdlY2tvKSUyMENocm9tZSUyRjEwNi4wLjAuMCUyMFNhZmFyaSUyRjUzNy4zNiUyMiUyMGV0YWclM0QlMjJUUU9kaTBSVXFZaU4ybzdqVm9XSSUyMiUyMHZlcnNpb24lM0QlMjIyMC4yLjIlMjIlMjB0eXBlJTNEJTIyZGV2aWNlJTIyJTNFJTNDZGlhZ3JhbSUyMGlkJTNEJTIyQ3JaSUVubVFPTWhHSmZvWGZjQWolMjIlMjBuYW1lJTNEJTIyUGFnZS0xJTIyJTNFM1ZsTmI2TXdFUDAxSEZOaGclMkZrNGJwdHVWeXV0VkNtSGJrOHJDOXhnaWVEVU9BM3ByMTlURE1HbTJaQXFpWk9WY3ZBTVpteSUyRmVUT2VJWTUzdDZnZU9GNW12MWhLY2dlNmFlVjRVd2RDNEVQbzFEODMzVFNhTUZTS09hZXBtclJWek9nN1VVcFhhVmMwSmFVMlVUQ1dDN3JVbFFrckNwSUlUWWM1WjJ0OTJndkw5VldYZUU0R2lsbUM4NkgyaWFZaWE3UVJETGY2SDRUT3MzWmxFTVROa3dWdUo2dVRsQmxPMmJxbjh1NGQ3NDR6SnByUm9yb2plUTFlaTB2ejN2Y2RUN3VOY1ZLSU1TJTJCOHZqNVY3JTJGY1RuSzRlWHY4RUtYJTJGJTJCbWVjVFplVU41eXQxWUxWWnNXa1JrRllrMkZLNFhXZFVrTmtTSiUyRldUdGZTMzFHVmlrVXNKeUNFdWw0MEhYbWhGNUtLM3lqYmhnbFE3TncwNktDU0hDRnNRd1RkeWlub0IlMkJncTlsajVLWFBkOG9WUlp6dzJ0RGl2dnp6dkRXNERrUUdGMEFGN3d3dkVLZGJnNklHemg1WSUyRkFxMGklMkYxWUVxcFNUSFpVa1RIU2JPVmtWYTR6TjFwU1J4NEp2ZnRYQURVU3MlMkZHJTJGSzA2cyUyQmVidnJTSSUyQkZVbm8xd3BTd0Y1cUxkUU1FSzBqbUNwSVBVWUxoQm5vT3RlRUwlMkJBUUJTT1F2ek9SSDdBbkhvMXA3ZjBDZCUyQmEzV2M1RmpRTjMyN256bFRyZkRJcUR4SXh4b0FkTnA0cnNHSDVwanFyWDZPTVEwRkJ2JTJCUVlhakJZV0RvZzF2ZHNiOU9ON1NmYmpJTkwlMkJ0aHdsbFo3ZzlTem9SRWxoVlNuUGpvT0VFYWV6cEk4VEJJNFNmT2hxY0swdWdxVUlNbzFxJTJCQ3dDNXE4WFdnRmdBTk5lQmFKaHNZVVhKY0FtNFIwbkVEMERKdWwxNTYlMkJLNlIlMkJ3UEx0UWZ3cm9KcFBvZ04zQ3duTmpDaWFMc0UzSHc5UXExZkNPQTZxZzhmQkJwdW51dFp4aTBja2RtJTJCMkNSb0hZTFdIdmhhZXlDejZ3SDlBYW1vNk16TDhYTnYlMkZHRzhNVmRMbTc1azJuWXM5QmwyR3cySWJxSVlJaFFnTjQ2aU1JNE1Lb0tiRUxrJTJCZEtNb0FLajlsSEpvRjJKMndjQnNaMDdjaFlBUnBlR0JoRDZRY01FT3dvMEpqRWdMakdoWFhOamdybWVUdXg0eW1tUXpJWTZsNTZCUUNzOUx6M2JmNTgyMzBjaDhPNTVYZSUyRmtTVzAxMXglMkZxbVlwMHVJOHFhVTElMkZQUjhoQyUyQjdNTHNuc3pub291Wjc3ODRBVlVjMmVoaSUyRjklMkZacGVqMFVXSzJ6JTJCM211bmJ2d2k5JTJCNzglM0QlM0MlMkZkaWFncmFtJTNFJTNDJTJGbXhmaWxlJTNF0MU9dgAAIABJREFUeF7tnQl4VNX5xt8kkARCEiAsQTEsAlUrIAUERP9KVUAQrEWKVBFR1gBVAUEjhiIIigQhlLLFglCluBWhuIMtYots1UqLInvEBEICCWRf+D/feAeHYZZ779w7c2fmPc+TJ5Gc851zfuc6b8493/m+CLCQAAmoIXADgKsBNJOvBg0aXB0ZGXlVTU1NckVFRaPk5OTTubm5jaKjo09HRkbm1tTUZJ85c+YggFwAOQDk56/UdMQ6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)



---



![lagrida_latex_editor.png](data:image/png;base64,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)




"""

EmptySentences = {}
EmptySentencesIndex = 0
def ClustersCostFunctionAllWords(Clusters,ShowResults = True) : 
  global GetAllWords,SavedWords
  global EmptySentences,EmptySentencesIndex
  
  ClustersDiffs = []
  BetweenDiffs = []
  if ShowResults : print('Calculating Within Clusters Variance')
  for Cl in Clusters['Top Words'].split('Cluster')[1:] : 
    AllWords = Cl.split("'")[1::2]
    if len(AllWords) > 5 : 
      Diffs = []
      for i in range(len(AllWords)-1) : 
        for j in range(i+1,len(AllWords)) : 
          if AllWords[i] in SavedWords.keys() and AllWords[j] in SavedWords.keys() : 
            Diffs.append(float(WordDifference(AllWords[i],AllWords[j])))
          else : 
            Diffs.append(0)
      if len(Diffs) <= 1 : 
        EmptySentencesIndex+=1
        EmptySentences[EmptySentencesIndex] = ['AllWords_Within',Clusters]
        print(f'Total Empty Sentence {EmptySentencesIndex}')
      ClustersDiffs.append(np.mean(Diffs))
      
  ClusterWords = []
  for Cl in Clusters['Top Words'].split('Cluster')[1:] : 
    if len(Cl.split("'")[1::2]) > 5  : ClusterWords.append(Cl.split("'")[1::2])    
  if ShowResults : print('Calculating Between Clusters Variance')
  for i in range(len(ClusterWords)) : 
    TheseWords = ClusterWords[i]
    ExList = [j for j in range(len(ClusterWords)) if j != i]
    OtherWords = []
    for k in ExList : 
      OtherWords.extend(ClusterWords[k])
    
    for Word1 in TheseWords : 
      for Word2 in OtherWords : 
        if Word1 in SavedWords.keys() and Word2 in SavedWords.keys() : 
          BetweenDiffs.append(float(WordDifference(Word1,Word2)))
        else : 
          BetweenDiffs.append(0)
  F1 = np.mean(BetweenDiffs)
  F2 = np.mean(ClustersDiffs)

  if len(ClustersDiffs) <= 1 : 
    EmptySentencesIndex+=1
    EmptySentences[EmptySentencesIndex] = ['AllWords_Within',Clusters]
    print(f'Total Empty Sentence {EmptySentencesIndex}')
  if len(BetweenDiffs) <= 1 : 
    EmptySentencesIndex+=1
    EmptySentences[EmptySentencesIndex] = ['AllWords_Between',Clusters]
    print(f'Total Empty Sentence {EmptySentencesIndex}') 
  if ShowResults : print(f'Between Clusters Variance is {F1} and Within Clusters Variance is {F2}')
  return F1,F2

"""BCV : Mean Equation


![02 Mean.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfcAAAGXCAYAAACugRl9AAAAAXNSR0IArs4c6QAABfZ0RVh0bXhmaWxlACUzQ214ZmlsZSUyMGhvc3QlM0QlMjJhcHAuZGlhZ3JhbXMubmV0JTIyJTIwbW9kaWZpZWQlM0QlMjIyMDIyLTEwLTEwVDEwJTNBMDklM0EyMC42MzBaJTIyJTIwYWdlbnQlM0QlMjI1LjAlMjAoV2luZG93cyUyME5UJTIwMTAuMCUzQiUyMFdpbjY0JTNCJTIweDY0KSUyMEFwcGxlV2ViS2l0JTJGNTM3LjM2JTIwKEtIVE1MJTJDJTIwbGlrZSUyMEdlY2tvKSUyMENocm9tZSUyRjEwNi4wLjAuMCUyMFNhZmFyaSUyRjUzNy4zNiUyMiUyMGV0YWclM0QlMjJKclFtNV83ekpTRVk5eUJjU1FtSCUyMiUyMHZlcnNpb24lM0QlMjIyMC4yLjIlMjIlMjB0eXBlJTNEJTIyZGV2aWNlJTIyJTNFJTNDZGlhZ3JhbSUyMGlkJTNEJTIyQ3JaSUVubVFPTWhHSmZvWGZjQWolMjIlMjBuYW1lJTNEJTIyUGFnZS0xJTIyJTNFN1poZGI5c2dGSVolMkZUUzQ3R1glMkZFOW1XYnBwMDJaYXBVYWYyNHFaaWhNUnN4S1NhTjAxOCUyRnFNRTJKbEdUS1V1anFsSXVPTWR3Z09lOG9FTUd3V2hXWFhJNHp5Y01ZVHJ3UFZRTmd2T0I3NFBROXdmcTU2RlY3WWxqN1poeWduU24xbkZOWHJCMmV0cTdJQWlYVmtmQkdCVmtianN6VmhRNEU1WVBjczZXZHJkSFJ1MVo1M0NLSGNkMUJxbnJ2U0ZJNUxVMzhlUFclMkZ4V1RhVzVtQnNPMCUyRmpLRHByUGVTWmxEeEpZZFZ6QWVCQ1BPbUtoYnMycUVxWUpudU5UakxqWjhiUmJHY1NHMkdSQ3pDYyUyQiUyQmolMkJOZms0ZmZQOU1MJTJCbnhQZnB4RWRaUm5TQmQ2dzNxeFltVUl5Q2dTdGpUT2xqa1IlMkJIb09NJTJGVmxLZk10ZmJtWVVXa0IyWVRsdk03QUk2bXduUFJNeDhaYzRHcmpva0dEUW1vSXN4a1dmQ1c3NkFGJTJCcXVscCUyQmZpUnRwZHRNa0NvZDVGM0UyR2NVQXRnMnNSdUdjbUd4clFEc3VESWtZV1JqU3dDNEwyUiUyQlVlT0xBMTZ4QTRwc3Flbm0lMkJwbGZBTFI0dkxwWVlqNDNUZEt0em1YOGo2WnEyYkdXVm0lMkJ6WTB6QVFWaGhUUlA1TElOTndmU0dwUWJ1WUdvQjg1YzdoMXc1dnJyY2pPJTJCdldNelVqOXlia0h2aUFiZ3ZibHRjYWtkQWJmbVlEWjZHeDZNMjlxTGJiakZ4VmFnVTFXSEtISVVsaVhKSkl0U1FDNWN0NFZ2VVNCMXY1MTcwcExJJTJCT3EyYTl4MWpYUEZKMmtzUlFjTWpYbUZPWkc3eGR5TXFJaTQ3YlR2T3UzWFFGS00ybHFac05Mb2g2azNpcEZUUGpuNUxkbUNaM2dMOVVrb1V5emVQTjZ1UERycGo5YWszJTJGZzRwbEtTeiUyRmFDMTJsQ3ozREZpTnhLZTJwN3RVallsMVc5VVQycVc0bjFBb1ZoNyUyRmpIdlVBMUNDZlFxMFNiYmYlMkI3YXVORHFYWTNwVFdXbzlqZDFlOXZVdjhlWlJ0OXF2YVFxazJPUmJYSjNrUWJXcUpOamttendhZG05NkRaMU5Ic2lDNUtsVm5mazFTOENZYUZvMkpaREFsYm9LWGc3QThlTWNxVUpBcFdxSGZTSTZHMDU0S1VURlhCbFVsZEtQV2NxZEtLWkpDZTZnOHpnaERkOU1peWo4R0cybXlYWjFVQUlvdSUyQm40Uk91WmF1SzllUyUyRjFTdW1mSnhiVDZDRDUlMkJQTUk2JTJGMkJrWmV1NUw5N0FaY1I5c2JVYjhENThSQUJJckgxSHFQbWoybEE5cHR2ODExdmRiJTJCNDl0TVA0TCUzQyUyRmRpYWdyYW0lM0UlM0MlMkZteGZpbGUlM0VL0q2FAAAgAElEQVR4XuydC5xN9fr/P8NkmKu5meQWhdOvxETjIBGJSEqdya2LVMglKsntRLkch3NcoiM6oZlBdSK5lohEuSRC0okigxlzM3tmz2DM/F/PPrPnv4257Mtae6/LZ71e+6Vmvuv5Ps/7+539Wc9a3/V9/MCDBEiABAA/AE3snwYNGsRevXq1YWFhYVBBQYF8aly5ckU+1a9cuRIgwG644YZL1apVy/f3988r/uRWqVIl19/f//fff//9ewC/OHzImARIwIsE5A+aBwmQgLkIVAPQEUDr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)


---

![lagrida_latex_editor.png](data:image/png;base64,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)
"""

def ClustersCostFunctionMean(Clusters,ShowResults = True) : 
  global GetAllWords,SavedWords
  ClustersDiffs = []
  BetweenDiffs = []
  if ShowResults : print('Calculating Within Clusters Variance')
  for Cl in Clusters['Top Words'].split('Cluster')[1:] : 
    AllWords = Cl.split("'")[1::2]
    if len(AllWords) > 5 : 
      Diffs = []
      for i in range(len(AllWords)-1) : 
        for j in range(i+1,len(AllWords)) : 
          if AllWords[i] in SavedWords.keys() and AllWords[j] in SavedWords.keys() : 
            Diffs.append(float(WordDifference(AllWords[i],AllWords[j])))
          else : 
            Diffs.append(0)
      ClustersDiffs.append(np.mean(Diffs))
  ClusterWords = []
  for Cl in Clusters['Top Words'].split('Cluster')[1:] : 
    if len(Cl.split("'")[1::2]) > 5  : ClusterWords.append(Cl.split("'")[1::2])    
  if ShowResults : print('Calculating Between Clusters Variance')

  TheseWordsValuesMean = []
  for i in range(len(ClusterWords)) : 
    TheseWords = ClusterWords[i]
    for EachWord in TheseWords : 
      EachWord = EachWord.lower()
      if not EachWord in SavedWords.keys() : 
        if EachWord in EnglishWE.keys()  : 
          SavedWords[EachWord] = [i for i in EnglishWE[EachWord]]
        else : 
          SavedWords[EachWord] = [0 for i in range(300)]
    TheseWordsValues = [SavedWords[i] for i in TheseWords]
    if len(TheseWordsValues) > 0 : 
      TheseWordsValuesMean.append([np.matrix(TheseWordsValues).T[i].mean() for i in range(300)])
  
  for a in range(len(TheseWordsValuesMean)) : 
    for b in range(a+1,len(TheseWordsValuesMean)) : 
      BetweenDiffs.append(sum([(float(g)-float(m))**2 for g,m in zip(TheseWordsValuesMean[a],TheseWordsValuesMean[b])]))

  F1 = np.mean(BetweenDiffs)
  F2 = np.mean(ClustersDiffs)
  global EmptySentences,EmptySentencesIndex
  if len(ClustersDiffs) <= 1 : 
    EmptySentencesIndex+=1
    EmptySentences[EmptySentencesIndex] = ['Mean_Within',Clusters]
    print(f'Total Empty Sentence {EmptySentencesIndex}')
  if len(BetweenDiffs) <= 1 : 
    EmptySentencesIndex+=1
    EmptySentences[EmptySentencesIndex] = ['Mean_Between',Clusters]
    print(f'Total Empty Sentence {EmptySentencesIndex}') 
  if ShowResults : print(f'Between Clusters Variance is {F1} and Within Clusters Variance is {F2}')
  return F1,F2

"""BCV : Min Equation

![03 Min.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfcAAAGXCAYAAACugRl9AAAAAXNSR0IArs4c6QAABbJ0RVh0bXhmaWxlACUzQ214ZmlsZSUyMGhvc3QlM0QlMjJhcHAuZGlhZ3JhbXMubmV0JTIyJTIwbW9kaWZpZWQlM0QlMjIyMDIyLTEwLTEwVDEwJTNBMTMlM0EwMC42NThaJTIyJTIwYWdlbnQlM0QlMjI1LjAlMjAoV2luZG93cyUyME5UJTIwMTAuMCUzQiUyMFdpbjY0JTNCJTIweDY0KSUyMEFwcGxlV2ViS2l0JTJGNTM3LjM2JTIwKEtIVE1MJTJDJTIwbGlrZSUyMEdlY2tvKSUyMENocm9tZSUyRjEwNi4wLjAuMCUyMFNhZmFyaSUyRjUzNy4zNiUyMiUyMGV0YWclM0QlMjJybTN1Vnd2OXlBUXJsT1BscXE3SCUyMiUyMHZlcnNpb24lM0QlMjIyMC4yLjIlMjIlMjB0eXBlJTNEJTIyZGV2aWNlJTIyJTNFJTNDZGlhZ3JhbSUyMGlkJTNEJTIyQ3JaSUVubVFPTWhHSmZvWGZjQWolMjIlMjBuYW1lJTNEJTIyUGFnZS0xJTIyJTNFN1ZqYmp0b3dFUDJhUENJUjV3YVA3TUxTaTJpUnFMcExYMVp1WW9nckV3ZkhRTEpmWDRjNDVGNnlLZ3FwVklrSHo3RXo5aHdmenhncjJ1TXVuRFBvdXd2cUlLS0FvUk1xMmxRQlFOVUJVT0xmMElrU3hMSWtzR1hZa1lNeVlJWGZrQVNIRWoxZ0J3V0ZnWnhTd3JGZkJHM3FlY2ptQlF3eVJrJTJGRllSdEtpclA2Y0lzcXdNcUdwSW8lMkJZNGU3Q1RvQ1ZvWiUyRlFIanJwak9yNWpqcDJjRjBzSXdrY0tGRFR6bElteW5hSTZPVUo2MWQlMkJJaElURjdLUyUyRkxkVTBQdlpXRU1lYnpOQnhaZE1Qdnp6UHE1ZVAzMWZmeEVqaiUyRndsNEdSZURsQ2NwQUJ5OFh5S0dWQWVCRmtDJTJCUGg1R0tPVmo2MDQ1NlQyRyUyQkJ1WHhIaEtXS0pnejhaQWMyT0VSaTBvZnFDdVdpajRoeEZPWWd1ZUk1b2p2RVdTU0d5RjR3bHV4SiUyQlFCRDJxZHNNMVJkUnVIbU55SUZvUlRBOXVJNzQwZzBKRTN2b0V6ck9XVzZVYVRNVU5WN1V3WjZUdGxZS3pIV3BjajIlMkIlMkJmd2JUYUF6bUclMkJmelVkdHY1RVNKdHpLZktKSHpkdFJvUGdPbSUyQk1jc2d4OVlRNUVNdSUyQkNXJTJGcUdGeVZXcHIlMkI4cnlsMk0xcFMlMkJmdk9XJTJGYXNDZzR6UVIzNXExRlV1c0JiN3FsM2sxdnRZbk5hcEhZUEdjUzMwTmk1Z2dNQW13TExnSU9HYSUyRkNCZm9PbmhQbnQlMkJsUVdDakUlMkZDWFhYdWZhMDVnY0ZhUldsTGVXaUdFUktXTHBlRTlFJTJGWkkzMW5uajdHcDBzVEpYc1ZuMjFiaWZBVDB3RzExUGJvS0RMZUl0VGpOeUNuZTBxanh5MjIlMkZVYkglMkJLTVVTRUpJJTJGRm0xMmRKdVFNUzRwRmFObXBMZDFGOUxLc2tzRGxWJTJGbWJXTW1ScmhjZGFWYkpVY0pNeGRGWm9wZXcyNTEyRTJ3bTM5aHlPbGpTNkd1MCUyQkJoTnZFRm5TYkp5c212MDBuellTeXdabHRsZGtxeWpyY1V0cGdlMGlUOG5KZG82ckMxMXRIVldXdjZLTm0ya2w4NmtkViUyRmE5SzVLUzR1U2tCV0JjMDNRbTByQ2U4dVUyVkNtYXRQJTJCOVZyekIlMkZWZHJ6VmFuMHFMY2F2U29uZGNXdHE4SiUyRnpiRjZKRzhkOVF0S0JHdEkyRiUyRkw5bUd6VXJ6T3g5TFJtZXZWSnFzOTglM0QlM0MlMkZkaWFncmFtJTNFJTNDJTJGbXhmaWxlJTNFT9DfuAAAIABJREFUeF7tnQl4k1W6x/9dSCFtWpq2VGUpoMg4slWYMlDZBBVREJHbYRsFGUAUEHRGBPEqDuACM4ACUrgjxbaAo4IoyqYOUIpCGQYGFEVAYNjapgtNk5a2NPc5vQm3lKZN0uTLt/zP8+QptGd53997kn/e7/vOOQFgIQESIAEgAMCdjldcXFz8tWvX2lRWVoZWVFSIV5Py8nLxalxeXh4igDVq1OiqTqcrDQ4OLrG/LIGBgZbg4OAzZ86c+SeAE9VeZEwCJCAhAfGGZiEBEtAWAR2AvgC6h4aG9gHwK4vFctttt91mvuuuu9C5c+ewDh06BEZGRiIsLAwGg+GGn+J3ohQXF8NsNlf9rP7v/Px8HDt2rPLIkSOW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)

---


![lagrida_latex_editor (1).png](data:image/png;base64,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)

"""

def ClustersCostFunctionMin(Clusters,ShowResults = True) : 
  global GetAllWords,SavedWords
  ClustersDiffs = []
  BetweenDiffs = []
  if ShowResults : print('Calculating Within Clusters Variance')
  for Cl in Clusters['Top Words'].split('Cluster')[1:] : 
    AllWords = Cl.split("'")[1::2]
    if len(AllWords) > 5 : 
      Diffs = []
      for i in range(len(AllWords)-1) : 
        for j in range(i+1,len(AllWords)) : 
          if AllWords[i] in SavedWords.keys() and AllWords[j] in SavedWords.keys() : 
            Diffs.append(float(WordDifference(AllWords[i],AllWords[j])))
          else : 
            Diffs.append(0)
      ClustersDiffs.append(np.mean(Diffs))
  ClusterWords = []
  for Cl in Clusters['Top Words'].split('Cluster')[1:] : 
    if len(Cl.split("'")[1::2]) > 5  : ClusterWords.append(Cl.split("'")[1::2])    
  if ShowResults : print('Calculating Between Clusters Variance')
  AllTheseWords = []
  for i in range(len(ClusterWords)) : 
    TheseWords = ClusterWords[i]
    for EachWord in TheseWords : 
      EachWord = EachWord.lower()
      if not EachWord in SavedWords.keys() : 
        if EachWord in EnglishWE.keys()  : 
          SavedWords[EachWord] = [i for i in EnglishWE[EachWord]]
        else : 
          SavedWords[EachWord] = [0 for i in range(300)]
    TheseWordsValues = [SavedWords[i] for i in TheseWords]
    AllTheseWords.append(TheseWordsValues)
  for EachGroup in AllTheseWords : 
    for OtherGroup in [Group for Group in AllTheseWords if Group != EachGroup ] : 
      GroupsWordsDiff = []
      for WordA in  EachGroup : 
        for WordB in OtherGroup : 
          if WordA != WordB : 
            GroupsWordsDiff.append(sum([(float(g)-float(m))**2 for g,m in zip(WordA,WordB)]))
      if len(GroupsWordsDiff) > 0 : BetweenDiffs.append(min(GroupsWordsDiff))

  F1 = np.mean(BetweenDiffs)
  F2 = np.mean(ClustersDiffs)
  global EmptySentences,EmptySentencesIndex
  if len(ClustersDiffs) <= 1 : 
    EmptySentencesIndex+=1
    EmptySentences[EmptySentencesIndex] = ['Min_Within',Clusters]
    print(f'Total Empty Sentence {EmptySentencesIndex}')
  if len(BetweenDiffs) <= 1 : 
    EmptySentencesIndex+=1
    EmptySentences[EmptySentencesIndex] = ['Min_Between',Clusters]
    print(f'Total Empty Sentence {EmptySentencesIndex}') 
  if ShowResults : print(f'Between Clusters Variance is {F1} and Within Clusters Variance is {F2}')
  return F1,F2

"""BCV : Max Equation : 


![04 Max.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAhQAAAGfCAYAAAAH5UtjAAAAAXNSR0IArs4c6QAABaJ0RVh0bXhmaWxlACUzQ214ZmlsZSUyMGhvc3QlM0QlMjJhcHAuZGlhZ3JhbXMubmV0JTIyJTIwbW9kaWZpZWQlM0QlMjIyMDIyLTEwLTEwVDEwJTNBMTUlM0EzMy4zMzZaJTIyJTIwYWdlbnQlM0QlMjI1LjAlMjAoV2luZG93cyUyME5UJTIwMTAuMCUzQiUyMFdpbjY0JTNCJTIweDY0KSUyMEFwcGxlV2ViS2l0JTJGNTM3LjM2JTIwKEtIVE1MJTJDJTIwbGlrZSUyMEdlY2tvKSUyMENocm9tZSUyRjEwNi4wLjAuMCUyMFNhZmFyaSUyRjUzNy4zNiUyMiUyMGV0YWclM0QlMjJxR3NCcTd5Um04T3dpOXpEeW1kVSUyMiUyMHZlcnNpb24lM0QlMjIyMC4yLjIlMjIlMjB0eXBlJTNEJTIyZGV2aWNlJTIyJTNFJTNDZGlhZ3JhbSUyMGlkJTNEJTIyQ3JaSUVubVFPTWhHSmZvWGZjQWolMjIlMjBuYW1lJTNEJTIyUGFnZS0xJTIyJTNFN1ZoZGo2SXdGUDAxUHBwSXk0YzhPcVBqZnNSZEV6Yzc0NzVNdWxDbEc2Ullxc0w4JTJCaTFTaElLT3pNYWdKcHZ3MEh0YWJudFBEJTJGZmUwSUdQcTNqTVVPaE5xSXY5RHVpNWNRY09Pd0JvT2dDZDlPbTVTWVpZbGdTV2pMaHlVUUhNeUJ1V1lFJTJCaUclMkJMaVNGbklLZlU1Q1ZYUW9VR0FIYTVnaURHNlU1Y3RxSyUyRnVHcUlscmdFekIlMkZsMTlKbTQzTXZRUHJBSyUyRkJNbVN5JTJGZldUUHRiR2FGOHNVeWtzaERMdDJWSURqcXdFZEdLYzlHcSUyRmdSJTJCeWw1T1MlMkZaZTA4blpnOEhZempnVFY2dzZJUTVYMGZXNzhucm41JTJGMms3JTJGOVJiNTFqY3pMRnZrYkdiQThMRTl5Qm9RWFFiWXdIblllNFhnV0lpZWQyWW43RnBqSFY3NndOREZFVVpqZHdJTEVXR3o2VUQlMkJoUFBRV000N2pFaVJQUE1aMGhUbEx4Qkk1QzJ6Sm5wUVBNS1M5S3k1RDAyVVVYdmtpY2hCSkFTd1B2Z3VPeEVEUzlBSEs0STFUcGhzcVpZYW1YWnN5Y09PVTJiRENXSnNpVzYlMkJmNDdkUkY3bWI4ZnJWZE5uOGklMkI4MyUyQlM1RlBnblRvY05vRkozbmpWR09PS0dCTUx2aTJCZmhUY3VsSllrellWMXFlZm9yODVaakY2Y3RQOCUyQk44d1p0czVMVjRKVjVhNURVYm9BM281TGFUTmh2amJlamljMXFrTmdDZDVEMklTbHpQb29pNGdndUlvNFlyOE1LZlp2QVRmUGJzQ2NzSEJQJTJCVWhyUFMlMkJOaFNvNEdjaXNwVzFQTWlJZ1VzM3g5SUtKJTJCS1J2enNyRjMxVDlZaGF2VXJQbzZlWjhSM1RBSG4wOXVnb01sNWcyJTJCWnV3cVBWcGRIcVhyTjQ1Y2Y0NHg3QXRKYnRYTzdwZ201QTVUU2tSb3BhOVdWWjllbFZVV3VIeXIzSWxWSE9tNjZnaGFGVWNaTXpWSGU0a2V3bTcydFp0Z01makJwc1B1bENiZms4bm5aQkIwN3lOSkduMURyY3FXMlY2U1BFWmJneTdtQm1qclYzcVpmcjJYYVpXMSUyQjZnc3dMYlVpbXpxMTZWTmI2dXlOS2dJUlEzWWx3VDlWRVg0YUpVeVQxU3BacFhsSGJHZHJ5endwaXVMY2FuS29yZGNXWnI4VHJqdmZ1aWslMkJQOWR0T0NJYU44cDIlMkY4MTIxU3p3aXglMkJyMlhMaTUlMkJVY1BRWCUzQyUyRmRpYWdyYW0lM0UlM0MlMkZteGZpbGUlM0Uw9hToAAAgAElEQVR4XuydCZyNZfvHf7OY4czWbKaibCEhBvEyZd9lCe9EtDAhWSKVbIksWQpFWaqhsUZ22cs29kRIiJAxZseZzaz/z33+M14xyzkzz/OcZ/ndn8/5eN/mvq/7ur7XM3N+93NvDmAhARIgARIgARIggWIScChmezYnARIwNgHxN6RK7qdcuXKBmZmZFbKystwyMjLEp1R6err4lExPT3cVqEqUKHHXxcUl1dnZOSXnk+To6Jjk7Ox85cqVK78CuHDfx9h0GT0JaIgABYWGkkVXScDOBFwANAXQwM3NrQmAp5OSkh5//PHHzdWqVUOtWrXca9So4ejt7Q13d3d4eHj861/x30RJTEyE2Wy2/Hv//46Pj8eZM2eyTp06lXTu3LnsyMhITzc3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)


---


![lagrida_latex_editor (2).png](data:image/png;base64,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)


"""

def ClustersCostFunctionMax(Clusters,ShowResults = True) : 
  global GetAllWords,SavedWords
  ClustersDiffs = []
  BetweenDiffs = []
  if ShowResults : print('Calculating Within Clusters Variance')
  for Cl in Clusters['Top Words'].split('Cluster')[1:] : 
    AllWords = Cl.split("'")[1::2]
    if len(AllWords) > 5 : 
      Diffs = []
      for i in range(len(AllWords)-1) : 
        for j in range(i+1,len(AllWords)) : 
          if AllWords[i] in SavedWords.keys() and AllWords[j] in SavedWords.keys() : 
            Diffs.append(float(WordDifference(AllWords[i],AllWords[j])))
          else : 
            Diffs.append(0)
      ClustersDiffs.append(np.mean(Diffs))
  ClusterWords = []
  for Cl in Clusters['Top Words'].split('Cluster')[1:] : 
    if len(Cl.split("'")[1::2]) > 5  : ClusterWords.append(Cl.split("'")[1::2])    
  if ShowResults : print('Calculating Between Clusters Variance')

  AllTheseWords = []
  for i in range(len(ClusterWords)) : 
    TheseWords = ClusterWords[i]
    for EachWord in TheseWords : 
      EachWord = EachWord.lower()
      if not EachWord in SavedWords.keys() : 
        if EachWord in EnglishWE.keys()  : 
          SavedWords[EachWord] = [i for i in EnglishWE[EachWord]]
        else : 
          SavedWords[EachWord] = [0 for i in range(300)]
    TheseWordsValues = [SavedWords[i] for i in TheseWords]
    AllTheseWords.append(TheseWordsValues)
  for EachGroup in AllTheseWords : 
    for OtherGroup in [Group for Group in AllTheseWords if Group != EachGroup ] : 
      GroupsWordsDiff = []
      for WordA in  EachGroup : 
        for WordB in OtherGroup : 
          if WordA != WordB : 
            GroupsWordsDiff.append(sum([(float(g)-float(m))**2 for g,m in zip(WordA,WordB)]))
      
      if len(GroupsWordsDiff) > 0 : BetweenDiffs.append(max(GroupsWordsDiff))
  F1 = np.mean(BetweenDiffs)
  F2 = np.mean(ClustersDiffs)
  global EmptySentences,EmptySentencesIndex
  if len(ClustersDiffs) <= 1 : 
    EmptySentencesIndex+=1
    EmptySentences[EmptySentencesIndex] = ['Max_Within',Clusters]
    print(f'Total Empty Sentence {EmptySentencesIndex}')
  if len(BetweenDiffs) <= 1 : 
    EmptySentencesIndex+=1
    EmptySentences[EmptySentencesIndex] = ['Max_Between',Clusters]
    print(f'Total Empty Sentence {EmptySentencesIndex}') 
  if ShowResults : print(f'Between Clusters Variance is {F1} and Within Clusters Variance is {F2}')
  return F1,F2

"""Coherence CF"""

def ClustersCostFunctionCoherence(Clusters,ShowResults = True) : 
  ClusterWords = []
  for Cl in Clusters['Top Words'].split('Cluster')[1:] : 
    if len(Cl.split("'")[1::2]) > 5  : ClusterWords.append(Cl.split("'")[1::2])    
  if ShowResults : print('Calculating Between Clusters Variance')
  AllTheseDict = {}
  for i in range(len(ClusterWords)) : 
    TheseWords = ClusterWords[i]
    TheseWords = [k.lower().strip() for k in TheseWords]
    AllTheseDict[i] = TheseWords
  AllCoherence = []
  for a in range(len(list(AllTheseDict.keys()))) : 
    for b in range(a+1,len(list(AllTheseDict.keys()))) : 
      if len(AllTheseDict[a]) > 1 and len(AllTheseDict[b])> 1 : 
        topics = [AllTheseDict[a],AllTheseDict[b]]
        AllNeededWords = []
        AllNeededWords.extend(AllTheseDict[a])
        AllNeededWords.extend(AllTheseDict[b])
        gensim_dictionary = corpora.Dictionary()
        for i,w in enumerate(AllNeededWords) : 
          common_dictionary.token2id[w] = i
          gensim_dictionary.token2id[w] = i
        common_corpus = [gensim_dictionary.doc2bow(text) for text in topics]
        cm = CoherenceModel(topics=topics, corpus=common_corpus, dictionary=common_dictionary, coherence='u_mass') 
        coherence = cm.get_coherence() 
        AllCoherence.append(float(coherence))

  global EmptySentences,EmptySentencesIndex
  if len(AllCoherence) < 1 : 
    EmptySentencesIndex+=1
    EmptySentences[EmptySentencesIndex] = ['Coherence',Clusters]
    print(f'Total Empty Sentence {EmptySentencesIndex}')

  if len(AllCoherence) > 0 : 
    return np.mean(AllCoherence)
  else : 
    return 0.0



"""# 4) Reading Data

Read data files and other needed files
"""

MainPath = r'/content/drive/MyDrive/Data/PhD/Week 24 All Data'
AllWordsWEDF = pd.read_csv(os.path.join(MainPath ,'0 Data','_AllWordsWE.csv'))
DataFiles = os.listdir(os.path.join(MainPath,'0 Data'))
DataFiles = [i for i in DataFiles if i[0:7]=='Cleaned']
DataFiles

AllWordsWEDF.shape

SelectedData = 'Cleaned_BTBusiness.csv'
data = pd.read_csv(os.path.join(MainPath,'0 Data',SelectedData))
SelectedData= SelectedData.split('.')[0].split('_')[1]
data.head()

AllWordsWEDF

# Word Embedding
# get the embedding value for english words
EnglishWE = {k:v for k,v in zip(AllWordsWEDF['Word'].tolist(),[AllWordsWEDF.loc[j,:].tolist()[2:] for j in range(AllWordsWEDF.shape[0])])}
print(len(list(EnglishWE.keys())))

"""# 5) Applying GSDMM"""

# applying gsdmm topic modeling
TrainTheModel = False
if TrainTheModel : 
  # ApplyGSDMM(3)
  # ApplyGSDMM(4)
  ApplyGSDMM(5)
  # ApplyGSDMM(6)
  # ApplyGSDMM(7)
  # ApplyGSDMM(8)
  # ApplyGSDMM(9)
  # ApplyGSDMM(10)



"""# 6) Evaluation Methods"""



"""Testing Coherence : c_uci"""

# Clusters = SortedResults[0]

# ClusterWords = []
# for Cl in Clusters['Top Words'].split('Cluster')[1:] : 
#   if len(Cl.split("'")[1::2]) > 5  : ClusterWords.append(Cl.split("'")[1::2])    
# AllTheseDict = {}
# for i in range(len(ClusterWords)) : 
#   TheseWords = ClusterWords[i]
#   TheseWords = [k.lower().strip() for k in TheseWords]
#   AllTheseDict[i] = TheseWords
# AllCoherence = []

# for a in range(len(list(AllTheseDict.keys()))) : # 0 ,1 ,2 , 3
#   for b in range(a+1,len(list(AllTheseDict.keys()))) : 
#     if len(AllTheseDict[a]) > 1 and len(AllTheseDict[b])> 1 : 
#       topics = [AllTheseDict[a],AllTheseDict[b]]
#       AllNeededWords = []
#       AllNeededWords.extend(AllTheseDict[a])
#       AllNeededWords.extend(AllTheseDict[b])
#       gensim_dictionary = corpora.Dictionary()
#       for i,w in enumerate(AllNeededWords) : 
#         common_dictionary.token2id[w] = i
#         gensim_dictionary.token2id[w] = i
#       common_corpus = [gensim_dictionary.doc2bow(text) for text in topics]
#       cm = CoherenceModel(topics=topics, texts=' '.join([str(i) for i in data['CleanedText'].tolist()]), dictionary=common_dictionary, coherence='c_uci')  
      
#       coherence = cm.get_coherence() 
#       AllCoherence.append(float(coherence))
# AllCoherence

"""### 5.6) Apply CFs"""



GetAllWords = []
for w in tqdm(range(3,11)) : 
  ThisFile =os.path.join(MainPath,SelectedData,'01 GSDMMFiles',f'Clusters Number {w}.csv')
  

  if os.path.exists(ThisFile) : 
    ResultsData = pd.read_csv(ThisFile)  
    for i in range(w) : 
      ResultsData[f'Cluster {i}'] = ResultsData[f'Cluster {i}'].apply(lambda x :  ClusterClean(x))
    for i in ResultsData['Top Words'].tolist() : 
      for j in i.split('Cluster')[1:] : 
        GetAllWords.extend(j.split("'")[1::2]) 
print(f'\nTotal Number of Unique Words {str(len(set(GetAllWords)))}')
p = 0
for i in set(GetAllWords) : 
  if i in EnglishWE.keys() : 
    p+=1
print(f'Number of Exist Words is {p} and Percentage of Words Exists in English Words {100*np.round(p/len(set(GetAllWords)),3)} %')
SavedWords = {}
for word in GetAllWords : 
  if word in EnglishWE.keys() : 
    SavedWords[word] = [i for i in EnglishWE[word]]
print(f'Number of Words in SavedWords {len(list(SavedWords.keys()))} ')





Evaluate = False
if Evaluate : 
  for w in range(3,11) : 
    ThisFile = os.path.join(MainPath,SelectedData,'01 GSDMMFiles',f'Clusters Number {w}.csv')

    if os.path.exists(ThisFile) : 
      ResultsData = pd.read_csv(ThisFile)  
      ResultsData['Parameters'] = ResultsData['Parameters'].apply(lambda x : [float(i) for i in x.strip('[]').split(',')])
      ResultsData['Doc Number'] = ResultsData['Doc Number'].apply(lambda x : [int(i) for i in x.strip('[]').split()])
      ResultsData['Top Index'] = ResultsData['Top Index'].apply(lambda x : [int(i) for i in x.strip('[]').split()])
      Losses = ResultsData['Loss'].tolist()
      Losses.sort()
      for i in range(w) : 
        ResultsData[f'Cluster {i}'] = ResultsData[f'Cluster {i}'].apply(lambda x :  ClusterClean(x))
      Losses = ResultsData['Loss'].tolist()
      Losses.sort()

      SortedResults = []
      for Loss in Losses : 
        for i in range(ResultsData.shape[0]) :
          if Loss ==ResultsData['Loss'][i] : 
            SortedResults.append({k:v for k,v in zip(list(ResultsData.keys()),[ResultsData[j][i] for j in list(ResultsData.keys())])})

      for i in tqdm (range(len(SortedResults))) : 
        for Cl in SortedResults[i]['Top Words'].split('Cluster')[1:] : 
          AllWords = Cl.split("'")[1::2]
      
      CostFunctionResults = {}
      for i in tqdm (range(len(SortedResults))) : 
        ThisClusterValue = list(ClustersCostFunctionAllWords(SortedResults[i],ShowResults=False))
        CostFunctionResults[i] = {'AllBCV':ThisClusterValue[0],'AllWCV':ThisClusterValue[1]}
    
      for i in tqdm (range(len(SortedResults))) : 
        ThisClusterValue = list(ClustersCostFunctionMean(SortedResults[i],ShowResults=False))
        CostFunctionResults[i]['MeanBCV'] = ThisClusterValue[0]
        CostFunctionResults[i]['MeanWCV'] = ThisClusterValue[1]
    
      for i in tqdm (range(len(SortedResults))) : 
        ThisClusterValue = list(ClustersCostFunctionMin(SortedResults[i],ShowResults=False))
        CostFunctionResults[i]['MinBCV'] = ThisClusterValue[0]
        CostFunctionResults[i]['MinWCV'] = ThisClusterValue[1]

      for i in tqdm (range(len(SortedResults))) : 
        ThisClusterValue = list(ClustersCostFunctionMax(SortedResults[i],ShowResults=False))
        CostFunctionResults[i]['MaxBCV'] = ThisClusterValue[0]
        CostFunctionResults[i]['MaxWCV'] = ThisClusterValue[1]
        CostFunctionResults[i]['CohBCV'] = ClustersCostFunctionCoherence(SortedResults[i],ShowResults=False)


      for i in tqdm(CostFunctionResults.keys()): 
        AllBCV =  CostFunctionResults[i]['AllBCV']
        AllWCV =  CostFunctionResults[i]['AllWCV']
        MeanBCV =  CostFunctionResults[i]['MeanBCV']
        MinBCV =  CostFunctionResults[i]['MinBCV']
        MaxBCV =  CostFunctionResults[i]['MaxBCV']    
        CohBCV = CostFunctionResults[i]['CohBCV']                 

        ThisAllD,ThisMeanD,ThisMinD,ThisMaxD,ThisCohD = {},{},{},{},{}
        l=0
        for a in np.linspace(0.01, 1, num=5) : 
          for b in np.linspace(0.01, 1, num=5): 
            l+=1
            ThisAllD[l] = [a,b,float(a*float(AllWCV)) - float(b*float(AllBCV))]
            ThisMeanD[l] = [a,b,float(a*float(AllWCV)) - float(b*float(MeanBCV))]
            ThisMinD[l] = [a,b,float(a*float(AllWCV)) - float(b*float(MinBCV))]
            ThisMaxD[l] = [a,b,float(a*float(AllWCV)) - float(b*float(MaxBCV))]
            ThisCohD[l] = [a,b,float(a*float(AllWCV)) - float(b*float(CohBCV))]
        CostFunctionResults[i]['AllCF'] = ThisAllD
        CostFunctionResults[i]['MeanCF'] = ThisMeanD
        CostFunctionResults[i]['MinCF'] = ThisMinD
        CostFunctionResults[i]['MaxCF'] = ThisMaxD
        CostFunctionResults[i]['CohCF'] = ThisCohD
      for i in range(len(SortedResults)) : 
        for Item in ['AllBCV','AllWCV','MeanBCV','MinWCV','MaxBCV','MeanWCV','MinBCV','MaxWCV','CohBCV','AllCF','MeanCF','MinCF','MaxCF','CohCF'] : 
          SortedResults[i][Item] = CostFunctionResults[i][Item]

      Alpha,Beta,A,B,AllBCV,MeanBCV,MinBCV,MaxBCV,CohBCV,WCV,IDs,AllCF,MeanCF,MinCF,MaxCF,CohCF = [],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]
      n=0
      for i in SortedResults : 
        for k in i['MeanCF'].values() : 
          MeanCF.append(k[2])
        for k in i['MinCF'].values() : 
          MinCF.append(k[2])
        for k in i['MaxCF'].values() : 
          MaxCF.append(k[2])      
        for k in i['CohCF'].values() : 
          CohCF.append(k[2])      
        for j,k in i['AllCF'].items() : 
          n+=1
          IDs.append(n)
          AllCF.append(k[2])
          AllBCV.append(i['AllBCV'])
          MeanBCV.append(i['MeanBCV'])
          MinBCV.append(i['MinBCV'])
          MaxBCV.append(i['MaxBCV'])
          CohBCV.append(i['CohBCV'])
          WCV.append(i['AllWCV'])
          A.append(k[0])
          B.append(k[1])
          Alpha.append(i['Parameters'][0])
          Beta.append(i['Parameters'][1])

      ResultsDF = pd.DataFrame(list(zip(IDs,Alpha,Beta,A,B,WCV,AllBCV,AllCF,MeanBCV,MeanCF,MinBCV,MinCF,MaxBCV,MaxCF,CohBCV,CohCF)),columns = ['IDs','Alpha','Beta','A','B','WCV','AllBCV','AllCF','MeanBCV','MeanCF','MinBCV','MinCF','MaxBCV','MaxCF','CohBCV','CohCF'])
      if not os.path.exists(os.path.join(MainPath,SelectedData,'02 Result DF'))  :  os.makedirs(os.path.join(MainPath,SelectedData,'02 Result DF'))
      ResultsDF.to_csv(os.path.join(MainPath,SelectedData,'02 Result DF' ,f'ResultsDF{w}.csv'))



if Evaluate : 
  for w in range(3,11) : 
    ThisFile = os.path.join(MainPath,SelectedData,'02 Result DF' ,f'ResultsDF{w}.csv')
    if not os.path.exists(os.path.join(MainPath,SelectedData,'03 Best Values')) :  os.makedirs(os.path.join(MainPath,SelectedData,'03 Best Values'))
    if os.path.exists(ThisFile) : 
      ResultsDF = pd.read_csv(ThisFile) 
      if 'index' in ResultsDF.columns : ResultsDF.drop(['index'],axis=1,inplace=True)
      if 'Unnamed: 0' in ResultsDF.columns : ResultsDF.drop(['Unnamed: 0'],axis=1,inplace=True)
      CalculatedCFs = ['AllCF','MeanCF','MinCF','MaxCF','CohCF']
      CFsDataFrame = pd.DataFrame()
      for CF in CalculatedCFs : 
        ResultLists = []
        for A in ResultsDF['A'].unique() : 
          for B in ResultsDF['B'].unique() : 
            MinCF = ResultsDF[ResultsDF['A'] == A][ResultsDF['B'] == B][CF].min()
            ThisList = ResultsDF[ResultsDF[CF] == MinCF].iloc[0,:].tolist()
            ResultLists.append([ThisList[0]] + ThisList[3:5]+ThisList[1:3]+ThisList[5:])
        col_names = ['Trial Number','A','B','Alpha','Beta','WCV','AllBCV','AllCF','MeanBCV','MeanCF','MinBCV','MinCF','MaxBCV','MaxCF','CohBCV','CohCF']
        
        ThisCFsDataFrame = pd.DataFrame(ResultLists, columns=col_names)
        ThisCFsDataFrame['SelectedCF'] = CF
        print(tabulate(ResultLists, headers=col_names, tablefmt="fancy_grid"))
        CFsDataFrame = pd.concat([CFsDataFrame,ThisCFsDataFrame],axis=0)
      CFsDataFrame.to_csv(os.path.join(MainPath,SelectedData,'03 Best Values',f'BestCFValue{w}.csv'))

if Evaluate : 
  Paths = [os.path.join(MainPath,SelectedData,'02 Result DF')  ,os.path.join(MainPath,SelectedData,'03 Best Values')]
  for Path in Paths : 
    if len(Path) > 1 : 
      for File in os.listdir(Path) : 
        ThisFile = os.path.join(Path,File)
        data = pd.read_csv(ThisFile)
        print(f'for file {File} Number of Nulss is {set(data.isna().sum().values)}')









"""### 5.6) Evaluation Methods"""



if Evaluate : 
  for w in range(3,11) : 
    ThisFile =os.path.join(MainPath,SelectedData,'02 Result DF',f'ResultsDF{w}.csv')
    if os.path.exists(ThisFile) : 
      data = pd.read_csv(ThisFile)  
      print(f'for clutser {w} shape is  {data.shape}')
      for alpha in data['Alpha'].unique() : 
        for beta in data['Beta'].unique() : 
          if len(data[data['Alpha']==alpha][data['Beta']==beta]['AllBCV'].unique()) !=1 : print('error')
          if len(data[data['Alpha']==alpha][data['Beta']==beta]['MeanBCV'].unique()) !=1 : print('error')
          if len(data[data['Alpha']==alpha][data['Beta']==beta]['MinBCV'].unique()) !=1 : print('error')
          if len(data[data['Alpha']==alpha][data['Beta']==beta]['MaxBCV'].unique()) !=1 : print('error')
          if len(data[data['Alpha']==alpha][data['Beta']==beta]['WCV'].unique()) !=1 : print('error')

      AllBCVDict = {}
      n=0
      for alpha in data['Alpha'].unique() : 
        for beta in data['Beta'].unique() : 
          n+=1
          AllBCVDict[n] = {'Alpha': alpha,
                          'Beta':beta,
                          'AllBCV':data[data['Alpha']==alpha][data['Beta']==beta]['AllBCV'].unique()[0],
                          'MeanBCV':data[data['Alpha']==alpha][data['Beta']==beta]['MeanBCV'].unique()[0],
                          'MinBCV':data[data['Alpha']==alpha][data['Beta']==beta]['MinBCV'].unique()[0],
                          'MaxBCV':data[data['Alpha']==alpha][data['Beta']==beta]['MaxBCV'].unique()[0],
                          'WBCV':data[data['Alpha']==alpha][data['Beta']==beta]['WCV'].unique()[0],
                          'CohBCV':data[data['Alpha']==alpha][data['Beta']==beta]['CohBCV'].unique()[0],
                          'EqualParameters_AllBCV' : data[data['Alpha']==alpha][data['Beta']==beta]['WCV'].unique()[0] -data[data['Alpha']==alpha][data['Beta']==beta]['AllBCV'].unique()[0],
                          'EqualParameters_MeanBCV' : data[data['Alpha']==alpha][data['Beta']==beta]['WCV'].unique()[0] -data[data['Alpha']==alpha][data['Beta']==beta]['MeanBCV'].unique()[0],
                          'EqualParameters_MinBCV' : data[data['Alpha']==alpha][data['Beta']==beta]['WCV'].unique()[0] -data[data['Alpha']==alpha][data['Beta']==beta]['MinBCV'].unique()[0],
                          'EqualParameters_MaxBCV' : data[data['Alpha']==alpha][data['Beta']==beta]['WCV'].unique()[0] -data[data['Alpha']==alpha][data['Beta']==beta]['MaxBCV'].unique()[0],
                          'EqualParameters_CohBCV' : data[data['Alpha']==alpha][data['Beta']==beta]['WCV'].unique()[0] -data[data['Alpha']==alpha][data['Beta']==beta]['CohBCV'].unique()[0]}
      data = pd.DataFrame(AllBCVDict).T
      data.fillna(99,inplace=True)
      data['MincF'] = data.apply(lambda x : min(x.AllBCV,x.MeanBCV,x.MinBCV,x.MaxBCV,x.WBCV,x.CohBCV,x.EqualParameters_AllBCV,x.EqualParameters_MeanBCV,x.EqualParameters_MinBCV,x.EqualParameters_MaxBCV,x.EqualParameters_CohBCV),axis=1)
      data = data.sort_values(['Alpha', 'Beta'],ascending = [True, True])

      if not os.path.exists(os.path.join(MainPath,SelectedData, '06 Combined CFs')) :  os.makedirs(os.path.join(MainPath,SelectedData, '06 Combined CFs'))
      data.to_csv(os.path.join(MainPath,SelectedData, '06 Combined CFs',f'CombinedCFs{w}.csv'))

if Evaluate : 
  for w in range(3,11) : 
    ThisFile = os.path.join(MainPath,SelectedData,'06 Combined CFs',f'CombinedCFs{w}.csv')
    if os.path.exists(ThisFile) : 
      data = pd.read_csv(ThisFile)  
      print(data.shape)

data

if Evaluate : 
  ValuesDict = {}
  for CF in ['AllBCV', 'MeanBCV', 'MinBCV', 'MaxBCV','WBCV','CohBCV','EqualParameters_AllBCV', 'EqualParameters_MeanBCV','EqualParameters_MinBCV', 'EqualParameters_MaxBCV', 'EqualParameters_CohBCV', 'MincF'] : 
    ValuesDict[CF] = {'MinCF':data[CF].min(),'Alpha' : data[data[CF] == data[CF].min()]['Alpha'].values[0],'Beta' : data[data[CF] == data[CF].min()]['Beta'].values[0]}
  ValuesDict

if Evaluate :  pd.DataFrame(ValuesDict).T



"""# 7) Charts and Graphs

### 6.1) Alpha Vs BCV Values
"""

for n in range(3,11) : 
  ThisFile =os.path.join(MainPath,SelectedData,'02 Result DF',f'ResultsDF{n}.csv')
  
  if os.path.exists(ThisFile) : 
    data = pd.read_csv(ThisFile)
    for AValue in tqdm(sorted(list(data['A'].unique()))) : 
      ThisData = data[data['A']==AValue][data['B']==0.01]
      ThisData.reset_index(inplace=True)
      ThisData.drop(['index','Unnamed: 0'],axis=1,inplace=True)

      ThisAlphaValues = {}
      for i in ThisData['Beta'].unique() : 
        Data = ThisData[ThisData['Beta']==i]
        for j in Data['Alpha'].unique() : 
          if j in ThisAlphaValues.keys() : 
            ThisAlphaValues[j][i] =np.mean(Data[Data['Alpha']==j]['AllBCV'].tolist())
          else : 
            ThisAlphaValues[j] ={i : np.mean(Data[Data['Alpha']==j]['AllBCV'].tolist()) }
      ThisAlphaValues = dict(sorted(ThisAlphaValues.items()))

      ThisBetaValues = sorted(list(ThisAlphaValues[1.0].keys()))

      plt.figure(figsize = (30,15))

      for k in range(4) : 
        plt.subplot(2,2,k+1)
        plt.title('Alpha vs BCV Values')
        plt.xlabel('Alpha')
        plt.ylabel('All BCV')
        X = list(ThisAlphaValues.keys())
        for j in ThisBetaValues[k*5:(k+1)*5] : 
          plt.plot(X,[i[j] for i in ThisAlphaValues.values()],alpha=0.5,label = np.round(j,2))

        plt.legend(loc = 'best')

      if not os.path.exists(os.path.join(MainPath,SelectedData, '04 Alpha vs BCV Values')) :  os.makedirs(os.path.join(MainPath,SelectedData, '04 Alpha vs BCV Values'))
      plt.savefig(os.path.join(MainPath,SelectedData, '04 Alpha vs BCV Values', f'For {n} Clusters and A equals {AValue}.png'))

    for BValue in tqdm(sorted(list(data['B'].unique()))) : 
      ThisData = data[data['A']==0.01][data['B']==BValue]
      ThisData.reset_index(inplace=True)
      ThisData.drop(['index','Unnamed: 0'],axis=1,inplace=True)

      ThisAlphaValues = {}
      for i in ThisData['Beta'].unique() : 
        Data = ThisData[ThisData['Beta']==i]
        for j in Data['Alpha'].unique() : 
          if j in ThisAlphaValues.keys() : 
            ThisAlphaValues[j][i] =np.mean(Data[Data['Alpha']==j]['AllBCV'].tolist())
          else : 
            ThisAlphaValues[j] ={i : np.mean(Data[Data['Alpha']==j]['AllBCV'].tolist()) }
      ThisAlphaValues = dict(sorted(ThisAlphaValues.items()))

      ThisBetaValues = sorted(list(ThisAlphaValues[1.0].keys()))

      plt.figure(figsize = (30,15))

      for k in range(4) : 
        plt.subplot(2,2,k+1)
        plt.title('Alpha vs BCV Values')
        plt.xlabel('Alpha')
        plt.ylabel('All BCV')
        X = list(ThisAlphaValues.keys())
        for j in ThisBetaValues[k*5:(k+1)*5] : 
          plt.plot(X,[i[j] for i in ThisAlphaValues.values()],alpha=0.5,label = np.round(j,2))

        

        plt.legend(loc = 'best')

      plt.savefig(os.path.join(MainPath,SelectedData, '04 Alpha vs BCV Values',  f'For {n} Clusters and B equals {BValue}.png')  )

"""### 6.2) Beta Vs BCV Values"""

for n in range(3,11) : 
  ThisFile =os.path.join(MainPath,SelectedData,'02 Result DF',f'ResultsDF{n}.csv')
  
  if os.path.exists(ThisFile) : 
    data = pd.read_csv(ThisFile)
    for AValue in tqdm(sorted(list(data['A'].unique()))) : 
      ThisData = data[data['A']==AValue][data['B']==0.01]
      ThisData.reset_index(inplace=True)
      ThisData.drop(['index','Unnamed: 0'],axis=1,inplace=True)

      BetaValues = {}
      for i in ThisData['Alpha'].unique() : 
        Data = ThisData[ThisData['Alpha']==i]
        for j in Data['Beta'].unique() : 
          if j in BetaValues.keys() : 
            BetaValues[j][i] =np.mean(Data[Data['Beta']==j]['AllBCV'].tolist())
          else : 
            BetaValues[j] ={i : np.mean(Data[Data['Beta']==j]['AllBCV'].tolist()) }
      BetaValues = dict(sorted(BetaValues.items()))

      AlphaValues = sorted(list(BetaValues[1.0].keys()))

      plt.figure(figsize = (30,15))

      for k in range(4) : 
        plt.subplot(2,2,k+1)
        plt.title('Beta vs BCV Values')
        plt.xlabel('Beta')
        plt.ylabel('All BCV')
        X = list(BetaValues.keys())
        for j in AlphaValues[k*5:(k+1)*5] : 
          plt.plot(X,[i[j] for i in BetaValues.values()],alpha=0.5,label = np.round(j,2))

        plt.legend(loc = 'best')

      if not os.path.exists(os.path.join(MainPath,SelectedData, '05 Beta vs BCV Values')) :  os.makedirs(os.path.join(MainPath,SelectedData, '05 Beta vs BCV Values'))
      plt.savefig(os.path.join(MainPath,SelectedData, '05 Beta vs BCV Values', f'For {n} Clusters and A equals {AValue}.png'))

    for BValue in tqdm(sorted(list(data['B'].unique()))) : 
      ThisData = data[data['A']==0.01][data['B']==BValue]
      ThisData.reset_index(inplace=True)
      ThisData.drop(['index','Unnamed: 0'],axis=1,inplace=True)

      BetaValues = {}
      for i in ThisData['Alpha'].unique() : 
        Data = ThisData[ThisData['Alpha']==i]
        for j in Data['Beta'].unique() : 
          if j in BetaValues.keys() : 
            BetaValues[j][i] =np.mean(Data[Data['Beta']==j]['AllBCV'].tolist())
          else : 
            BetaValues[j] ={i : np.mean(Data[Data['Beta']==j]['AllBCV'].tolist()) }
      BetaValues = dict(sorted(BetaValues.items()))

      AlphaValues = sorted(list(BetaValues[1.0].keys()))

      plt.figure(figsize = (30,15))

      for k in range(4) : 
        plt.subplot(2,2,k+1)
        plt.title('Beta vs BCV Values')
        plt.xlabel('Beta')
        plt.ylabel('All BCV')
        X = list(BetaValues.keys())
        for j in AlphaValues[k*5:(k+1)*5] : 
          plt.plot(X,[i[j] for i in BetaValues.values()],alpha=0.5,label = np.round(j,2))

        plt.legend(loc = 'best')

      plt.savefig(os.path.join(MainPath,SelectedData, '05 Beta vs BCV Values', f'For {n} Clusters and B equals {BValue}.png')  )

"""### 6.3) Scatterplot for Clusters"""

for k in range(3,11) : 
  ThisFile =os.path.join(MainPath,SelectedData,'02 Result DF',f'ResultsDF{w}.csv')
  if os.path.exists(ThisFile) : 
    data = pd.read_csv(ThisFile)
    print(f'for cluster {k}')
    print(data.shape)
    if not os.path.exists(os.path.join(MainPath,SelectedData, '07 Scatterplot for Clusters')) :  os.makedirs(os.path.join(MainPath,SelectedData, '07 Scatterplot for Clusters'))
    if not os.path.exists(os.path.join(MainPath,SelectedData, '07 Scatterplot for Clusters',f'Cluster {k} graph for Alpha')) :  os.makedirs(os.path.join(MainPath,SelectedData, '07 Scatterplot for Clusters',f'Cluster {k} graph for Alpha'))
    if not os.path.exists(os.path.join(MainPath,SelectedData, '07 Scatterplot for Clusters',f'Cluster {k} graph for Beta')) : os.makedirs(os.path.join(MainPath,SelectedData, '07 Scatterplot for Clusters',f'Cluster {k} graph for Beta'))
    Values,MeanValues = {},{}
    for i in sorted(list(data['Alpha'].unique())): 
      ThisData = data[data['Alpha']==i]
      x,y = ThisData['Beta'].tolist(),ThisData['AllCF'].tolist()
      Values[i] = [x,y]
      X,Y = [],[]
      for m in set(ThisData['Beta'].tolist()) : 
        SpecificData = data[data['Alpha']==i][data['Beta']==m]
        X.append(m)
        Y.append(SpecificData['AllCF'].mean())
      MeanValues[i] = [X,Y]


    for n in range(20):
      x,y =  Values[list(Values.keys())[n]][0],Values[list(Values.keys())[n]][1]
      plt.figure(figsize = (20, 10))
      plt.title(f'CF graph for Alpha {list(Values.keys())[n]}')
      plt.xlabel('Beta')
      plt.ylabel('CF')
      plt.scatter(x,y,s=30,alpha=0.5,color= 'g') 
      plt.savefig(os.path.join(MainPath,SelectedData, '07 Scatterplot for Clusters',f'Cluster {k} graph for Alpha',f'{k} Cluster scatter CF graph for Alpha {list(Values.keys())[n]}.png'))

    for n in range(20):
      x,y =  MeanValues[list(MeanValues.keys())[n]][0],MeanValues[list(MeanValues.keys())[n]][1]
      plt.figure(figsize = (20, 10))
      plt.title(f'CF graph for Alpha {list(MeanValues.keys())[n]}')
      plt.xlabel('Beta')
      plt.ylabel('CF')
      plt.scatter(x,y,s=30,alpha=0.5,color= 'g') 
      plt.savefig(os.path.join(MainPath,SelectedData, '07 Scatterplot for Clusters',f'{k} Cluster plot CF graph for Alpha {list(MeanValues.keys())[n]}.png'))

    n=0
    plt.figure(figsize = (40,20))
    for i in range(20) : 
      n+=1
      plt.subplot(4,5,n)
      x,y =  Values[list(Values.keys())[n-1]][0],Values[list(Values.keys())[n-1]][1]
      plt.title(f'{k} Cluster CF graph for Alpha {list(Values.keys())[n-1]}')
      plt.scatter(x,y,s=30,alpha=0.3,color= 'g') 
    plt.savefig(os.path.join(MainPath,SelectedData, '07 Scatterplot for Clusters',f'Cluster {k} graph for Alpha',f'{k} Cluster scatter CF graph for Different Alpha.png'))
    n=0
    plt.figure(figsize = (40,20))
    for i in range(20) : 
      n+=1
      plt.subplot(4,5,n)
      x,y =  MeanValues[list(MeanValues.keys())[n-1]][0],MeanValues[list(MeanValues.keys())[n-1]][1]
      plt.title(f'{k} Cluster CF graph for Alpha {list(MeanValues.keys())[n-1]}')
      plt.scatter(x,y,s=30,alpha=0.3,color= 'g') 
    plt.savefig(os.path.join(MainPath,SelectedData, '07 Scatterplot for Clusters',f'Cluster {k} graph for Alpha',f'{k} Cluster plot CF graph for Different Alpha.png'))

  #######################################

    Values,MeanValues = {},{}
    for i in sorted(list(data['Beta'].unique())): 
      ThisData = data[data['Beta']==i]
      x,y = ThisData['Alpha'].tolist(),ThisData['AllCF'].tolist()
      Values[i] = [x,y]
      X,Y = [],[]
      for m in set(ThisData['Alpha'].tolist()) : 
        SpecificData = data[data['Beta']==i][data['Alpha']==m]
        X.append(m)
        Y.append(SpecificData['AllCF'].mean())
      MeanValues[i] = [X,Y]


    for n in range(20):
      x,y =  Values[list(Values.keys())[n]][0],Values[list(Values.keys())[n]][1]
      plt.figure(figsize = (20, 10))
      plt.title(f'CF graph for Beta {list(Values.keys())[n]}')
      plt.xlabel('Alpha')
      plt.ylabel('CF')
      plt.scatter(x,y,s=30,alpha=0.5,color= 'g') 
      plt.savefig(os.path.join(MainPath,SelectedData, '07 Scatterplot for Clusters',f'Cluster {k} graph for Beta/{k} Cluster scatter CF graph for Beta {list(Values.keys())[n]}.png'))

    for n in range(20):
      x,y =  MeanValues[list(MeanValues.keys())[n]][0],MeanValues[list(MeanValues.keys())[n]][1]
      plt.figure(figsize = (20, 10))
      plt.title(f'CF graph for Beta {list(MeanValues.keys())[n]}')
      plt.xlabel('Alpha')
      plt.ylabel('CF')
      plt.scatter(x,y,s=30,alpha=0.5,color= 'g') 
      plt.savefig(os.path.join(MainPath,SelectedData, '07 Scatterplot for Clusters',f'Cluster {k} graph for Beta/{k} Cluster plot CF graph for Beta {list(MeanValues.keys())[n]}.png'))
                        


    n=0
    plt.figure(figsize = (40,20))
    for i in range(20) : 
      n+=1
      plt.subplot(4,5,n)
      x,y =  Values[list(Values.keys())[n-1]][0],Values[list(Values.keys())[n-1]][1]
      plt.title(f'{k} Cluster CF graph for Beta {list(Values.keys())[n-1]}')
      plt.scatter(x,y,s=30,alpha=0.3,color= 'g') 
    plt.savefig(os.path.join(MainPath,SelectedData, '07 Scatterplot for Clusters',f'Cluster {k} graph for Beta',f'{k} Cluster scatter CF graph for Different Beta.png'))
                    
    n=0
    plt.figure(figsize = (40,20))
    for i in range(20) : 
      n+=1
      plt.subplot(4,5,n)
      x,y =  MeanValues[list(MeanValues.keys())[n-1]][0],MeanValues[list(MeanValues.keys())[n-1]][1]
      plt.title(f'{k} Cluster CF graph for Beta {list(MeanValues.keys())[n-1]}')
      plt.scatter(x,y,s=30,alpha=0.3,color= 'g') 
    plt.savefig(os.path.join(MainPath,SelectedData, '07 Scatterplot for Clusters',f'Cluster {k} graph for Beta',f'{k} Cluster plot CF graph for Different Beta.png'))

for k in range(3,11) : 
  ThisFile = os.path.join(MainPath,SelectedData,'02 Result DF',f'ResultsDF{k}.csv')
        
  
  if os.path.exists(ThisFile) : 
    data = pd.read_csv(ThisFile)
    print(data.shape)
    if not os.path.exists(os.path.join(MainPath,SelectedData,'07 Scatterplot for Clusters',f'Another Cluster {k} graph for Alpha')) : os.makedirs(os.path.join(MainPath,SelectedData,'07 Scatterplot for Clusters',f'Another Cluster {k} graph for Alpha'))
    if not os.path.exists(os.path.join(MainPath,SelectedData,'07 Scatterplot for Clusters',f'Another Cluster {k} graph for Beta')) : os.makedirs(os.path.join(MainPath,SelectedData,'07 Scatterplot for Clusters',f'Another Cluster {k} graph for Beta'))
    
    Values = {}
    for i in sorted(list(data['Alpha'].unique())): 
      ThisData = data[data['Alpha']==i]
      x,y = [],[]
      for m in set(ThisData['Beta'].tolist()) : 
        SpecificData = data[data['Alpha']==i][data['Beta']==m]
        x.append(m)
        y.append(SpecificData['AllCF'].mean())
      Values[i] = [x,y]

    for n in range(20):
      x,y =  Values[list(Values.keys())[n]][0],Values[list(Values.keys())[n]][1]
      plt.figure(figsize = (20, 10))
      plt.title(f'CF graph for Alpha {list(Values.keys())[n]}')
      plt.xlabel('Beta')
      plt.ylabel('CF')
      plt.scatter(x,y,s=30,alpha=0.5,color= 'g') 
      plt.savefig(os.path.join(MainPath,SelectedData,'07 Scatterplot for Clusters',f'Another Cluster {k} graph for Alpha',f'{k} Cluster CF graph for Alpha {list(Values.keys())[n]}.png'))

    n=0
    plt.figure(figsize = (40,20))
    for i in range(20) : 
      n+=1
      plt.subplot(4,5,n)
      x,y =  Values[list(Values.keys())[n-1]][0],Values[list(Values.keys())[n-1]][1]
      plt.title(f'{k} Cluster CF graph for Alpha {list(Values.keys())[n-1]}')
      plt.scatter(x,y,s=30,alpha=0.3,color= 'g') 
    plt.savefig(os.path.join(MainPath,SelectedData,'07 Scatterplot for Clusters',f'Another Cluster {k} graph for Alpha',f'{k} Cluster CF graph for Different Alpha.png'))

x = 5





# import pandas as pd

# data = pd.read_csv('/content/drive/MyDrive/Data/PhD/Week 18 BT Business/111.csv')
# data.drop('Unnamed: 0',axis=1,inplace=True)
# data

# data['0'].value_counts()

# data['1'].tolist()[0]

# data['1'].tolist()[0].split(':')

# for i in data['1'].tolist() : 
#   print('Group Index is : ' + i.split(':')[5].split(", 'T")[0])

#   for j,k in zip(range(18,27),['AllBCV','AllWCV','MeanBCV','MinWCV','MaxBCV','MeanWCV','MinBCV','MaxWCV','CohBCV','AllCF']) : 
#     print(f"Value of {k} is {  i.split(':')[j].split(',')[0]}  " )
#   print('Words are : ')
#   print(i.split(':')[8].split(r'\n')[0])
#   print(i.split(':')[9].split(r'\n')[0])
  
#   print('-----------------------------------------------')



data

# import numpy as np
# for k in range(10) : 
#   W1 = list(np.random.randn(300))
#   W2 = list(np.random.randn(300))
#   print('For Euclidean Distance')
#   print(f'      Normal Equation is {np.sqrt(sum([(float(i)-float(j))**2 for i,j in zip(W1,W2)]))} & LinAlg Equation is {np.linalg.norm(np.array(W1)-np.array(W2), ord = 2)}')
#   print('For Manhattan Distance')
#   print(f'      Normal Equation is {sum([abs(float(i)-float(j)) for i,j in zip(W1,W2)])} & LinAlg Equation is {np.linalg.norm(np.array(W1)-np.array(W2), ord = 1)}')
#   print('For Correlation-based Distance')
#   mean1 ,mean2= float(np.mean(W1)) , float(np.mean(W2) )
#   ss1,ss2 = sum([(float(i)-mean1)**2 for i in W1]),sum([(float(j)-mean2)**2 for j in W2])
#   numerator = sum([(float(i)-mean1)*(float(j)-mean2) for i,j in zip(W1,W2)])
#   ThisResult = 1 - numerator/np.sqrt(ss1*ss2)
#   print(f'      Normal Equation is {ThisResult} & LinAlg Equation is { 1 - np.corrcoef(W1,W2)[0][1]}')    
#   print('-----------------------------------------------')



"""# 8) Tables Analysis"""

import pandas as pd
import os
import numpy as np



Tables = True
if Tables : 
  Path = '/content/drive/MyDrive/Data/PhD/Week 24 All Data/0 Data'
  Files = [i for i in os.listdir(Path) if i[:7] == 'Cleaned']

  ColName = {'BTBusiness.csv':'Description','Vodafone Final Reviews.csv':'reviewBody','Orange TrustPilot Reviews.csv':'reviewBody','BT TrustPilot Reviews.csv':'reviewBody',
            'BT Forums Community.csv':'Description','VirginMedia TrustPilot Reviews.csv':'reviewBody'}


  CustomizedStopWords =  ['i', 'me', 'my', 'myself', 'we', 'our', 'ours', 'ourselves', 'you', "you're", "you've", "you'll", "you'd", 'your', 'yours', 'yourself', 'yourselves', 'he', 'him', 'his', 'himself', 'she', "she's", 'her', 'hers', 'herself',
                          'it', "it's", 'its', 'itself', 'they', 'them', 'their', 'theirs', 'themselves', 'what', 'which', 'who', 'whom', 'this', 'that', "that'll", 'these', 'those', 'am', 'is', 'are', 'was', 'were', 'be', 'been', 'being', 'have',
                          'has', 'had', 'having', 'do', 'does', 'did', 'doing', 'a', 'an', 'the', 'and', 'but', 'if', 'or', 'because', 'as', 'until', 'while', 'of', 'at', 'by', 'for', 'with', 'about', 'between', 'into', 'through','to', 'from', 'in',
                          'on', 'off', 'again', 'further', 'then', 'once', 'here', 'there', 'when', 'where', 'why', 'how', 'all', 'any', 'both', 'each', 'other', 'some', 'such','only', 'own', 'same', 'so', 'than', 'too', 'very', 's', 't', 'can',
                          'will', 'just', 'don', "don't", 'should', "should've", '&amp','amp','lia','li','ul','ol','blockquote','strong','table','font','image','someone','anyone','everyone','hello','hi','morning','can','use','evening','bye','tr']

  CustomizedStopWords = [i.lower().strip() for i in CustomizedStopWords]
  DataDict = {}
  for File in Files : 
    data = pd.read_csv(os.path.join(Path,File))
    print(data.shape)
    FileName = File.replace('Cleaned_','').replace('.csv','')
    DataDict[FileName] = {'Sample Size' : data.shape[0]}
    ThisCol = ColName[str(File).replace('Cleaned_','')]
    RawText,CleanedText = [str(i) for i in data[ThisCol].tolist()],[str(i) for i in data['CleanedText'].tolist()]
    DataDict[FileName]['Total Number of Words Before Cleaning'] = len(' '.join(RawText).split())
    DataDict[FileName]['Total Number of Words After Cleaning'] = len((' '.join(CleanedText)).split())
    NRawText,NCleanedText = [len(i.split()) for i in RawText],[len(i.split()) for i in CleanedText]
    DataDict[FileName]['Mean Number of Words Before Cleaning'] = np.round(np.mean(NRawText))
    DataDict[FileName]['Mean Number of Words After  Cleaning'] = np.round(np.mean(NCleanedText))
    DataDict[FileName]['Min Number of Words Before Cleaning'] = np.round(np.min(NRawText))
    DataDict[FileName]['Min Number of Words After  Cleaning'] = np.round(np.min(NCleanedText))  
    DataDict[FileName]['Max Number of Words Before Cleaning'] = np.round(np.max(NRawText))
    DataDict[FileName]['Max Number of Words After  Cleaning'] = np.round(np.max(NCleanedText))  
    DataDict[FileName]['SD Number of Words Before Cleaning'] = np.round(np.std(NRawText))
    DataDict[FileName]['SD Number of Words After  Cleaning'] = np.round(np.std(NCleanedText))  
    DataDict[FileName]['Percentage of SW in Words'] = np.round(len([i for i in ' '.join(RawText).split() if i.lower().strip() in CustomizedStopWords]) *100 / len(' '.join(RawText).split()),2)
  DataDict

if Tables :  
  pd.DataFrame(DataDict).T

if Tables :
  pd.DataFrame(DataDict).T.to_csv('/content/drive/MyDrive/Data/PhD/Week 24 All Data/DataAnalysis.csv')





if Tables :
  AllResult = pd.DataFrame()
  Path = '/content/drive/MyDrive/Data/PhD/Week 24 All Data'
  Folders = [name for name in os.listdir(Path) if os.path.isdir(os.path.join(Path, name)) ]
  Folders = [i for i in Folders if i[0]!= '0']
  DataDict = {}
  for File in Folders : 
    if os.path.exists(os.path.join(Path,File,'06 Combined CFs','CombinedCFs5.csv')) : 
      data = pd.read_csv(os.path.join(Path,File,'06 Combined CFs','CombinedCFs5.csv'))
      DataDict[File] = {'Alpha':{},'Beta':{},'Range of CF':{},'SD of CF':{}}
      for Type in ['WBCV','AllBCV','MeanBCV','MinBCV','MaxBCV','CohBCV','EqualParameters_AllBCV','EqualParameters_MeanBCV','EqualParameters_MinBCV','EqualParameters_MaxBCV','EqualParameters_CohBCV'] : 
        DataDict[File]['Alpha'][Type] = data[data[Type] == data[Type].min()]['Alpha'].values[0]
        DataDict[File]['Beta'][Type] = data[data[Type] == data[Type].min()]['Beta'].values[0]
        DataDict[File]['Range of CF'][Type] = data[Type].max()-data[Type].min()
        DataDict[File]['SD of CF'][Type] = data[Type].std()
      

  Round = 2
  
  D = pd.DataFrame(DataDict['BTBusiness']) 
  Word = 'BTBusiness'
  Slash = '\\' + '\\'
  k=-1
  k+=1
  print(f"WBCV  &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)} & {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"AllBCV  &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"MeanBCV &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"MinBCV   &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"MaxBCV  &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"CohBCV  &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"EqualParameters\_AllBCV   &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"EqualParameters\_MeanBCV  &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"EqualParameters\_MinBCV  &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"EqualParameters\_MaxBCV  &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"EqualParameters\_CohBCV  &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash} [1ex] ")

if Tables :
  D['Data'] = 'BTBusiness'
  AllResult = pd.concat([AllResult,D],axis=0)
  AllResult

if Tables :
  D = pd.DataFrame(DataDict['Orange TrustPilot Reviews']) 
  Word = 'Orange'
  Slash = '\\' + '\\'
  k=-1
  k+=1
  print(f"WBCV  &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)} & {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"AllBCV  &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"MeanBCV &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"MinBCV   &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"MaxBCV  &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"CohBCV  &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"EqualParameters\_AllBCV   &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"EqualParameters\_MeanBCV  &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"EqualParameters\_MinBCV  &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"EqualParameters\_MaxBCV  &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"EqualParameters\_CohBCV  &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash} [1ex] ")

if Tables :
  D['Data'] = 'Orange'
  AllResult = pd.concat([AllResult,D],axis=0)
  AllResult

if Tables :
  D = pd.DataFrame(DataDict['BT Forums Community']) 
  Word = 'BTCommunity'
  Slash = '\\' + '\\'
  k=-1
  k+=1
  print(f"WBCV  &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)} & {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"AllBCV  &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"MeanBCV &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"MinBCV   &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"MaxBCV  &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"CohBCV  &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"EqualParameters\_AllBCV   &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"EqualParameters\_MeanBCV  &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"EqualParameters\_MinBCV  &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"EqualParameters\_MaxBCV  &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"EqualParameters\_CohBCV  &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash} [1ex] ")

if Tables :
  D['Data'] = 'BTCommunity'
  AllResult = pd.concat([AllResult,D],axis=0)
  AllResult

if Tables :
  D = pd.DataFrame(DataDict['BT TrustPilot Reviews']) 
  Word = 'BTTrustPilot'
  Slash = '\\' + '\\'
  k=-1
  k+=1
  print(f"WBCV  &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)} & {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"AllBCV  &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"MeanBCV &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"MinBCV   &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"MaxBCV  &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"CohBCV  &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"EqualParameters\_AllBCV   &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"EqualParameters\_MeanBCV  &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"EqualParameters\_MinBCV  &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"EqualParameters\_MaxBCV  &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"EqualParameters\_CohBCV  &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash} [1ex] ")

if Tables :
  D['Data'] = 'BTTrustPilot'
  AllResult = pd.concat([AllResult,D],axis=0)
  AllResult

if Tables :
  D = pd.DataFrame(DataDict['Vodafone Final Reviews']) 
  Word = 'Vodafone'
  Slash = '\\' + '\\'
  k=-1
  k+=1
  print(f"WBCV  &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)} & {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"AllBCV  &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"MeanBCV &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"MinBCV   &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"MaxBCV  &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"CohBCV  &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"EqualParameters\_AllBCV   &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"EqualParameters\_MeanBCV  &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"EqualParameters\_MinBCV  &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"EqualParameters\_MaxBCV  &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"EqualParameters\_CohBCV  &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash} [1ex] ")

if Tables :
  D['Data'] = 'Vodafone'
  AllResult = pd.concat([AllResult,D],axis=0)
  AllResult

if Tables :
  D = pd.DataFrame(DataDict['VirginMedia TrustPilot Reviews']) 
  Word = 'VirginMedia'
  Slash = '\\' + '\\'
  k=-1
  k+=1
  print(f"WBCV  &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)} & {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"AllBCV  &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"MeanBCV &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"MinBCV   &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"MaxBCV  &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"CohBCV  &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"EqualParameters\_AllBCV   &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"EqualParameters\_MeanBCV  &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"EqualParameters\_MinBCV  &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"EqualParameters\_MaxBCV  &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  k+=1
  print(f"EqualParameters\_CohBCV  &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash} [1ex] ")

if Tables :
  D['Data'] = 'VirginMedia'
  AllResult = pd.concat([AllResult,D],axis=0)
  AllResult

if Tables :AllResult.to_csv('/content/drive/MyDrive/Data/PhD/Week 24 All Data/0 Data/_CombinedBestValues.csv')

if Tables :AllResult.boxplot(column =['Alpha'], grid = False)

if Tables :AllResult.boxplot(column =['Beta'], grid = False)

if Tables :AllResult.describe().T.head()

if Tables :AllResult.describe().T.to_csv('/content/drive/MyDrive/Data/PhD/Week 24 All Data/0 Data/_CombinedBestValuesStatistics.csv')

A = AllResult.describe().T
A

Slash = '\\' + '\\'
for i in A.iterrows() : 
  V = '&'.join([str(np.round(j,Round)) for j in  i[1].values[1:]])
  print(f'{i[0]} & {V} {Slash}')
  

  # print(f"WBCV  &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)} & {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} ")
  # k+=1
  # print(f"AllBCV  &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  # k+=1
  # print(f"MeanBCV &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  # k+=1
  # print(f"MinBCV   &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")
  # k+=1
  # print(f"MaxBCV  &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} &  {Word} {Slash}")

Alpha & 0.49 & 0.27 & 0.05 & 0.21 & 0.55 & 0.75 & 1.0\\
Beta & 0.64 & 0.33 & 0.05 & 0.37 & 0.75 & 0.95 & 1.0\\
Range of CF & 26.44 & 42.74 & 0.1 & 0.39 & 0.62 & 21.15 & 124.32\\
SD of CF  & 7.55 & 13.73 & 0.02 & 0.07 & 0.12 & 7.28 & 42.71\\[1ex] % [1ex] adds vertical

Tables = True
import pandas as pd
import os

if Tables :
  MainPath = r'/content/drive/MyDrive/Data/PhD/Week 24 All Data'
  DataFiles = os.listdir(os.path.join(MainPath,'0 Data'))
  DataFiles = [i for i in DataFiles if i[0] =='C']

  for File in DataFiles : 
    data = pd.read_csv(os.path.join(MainPath ,'0 Data',File))
    print(File)
    Text = ' '.join([str(i) for i in data['CleanedText'].tolist()]).split()
    print(list(pd.Series(Text).value_counts().index[:10]))


  # Cleaned_BTBusiness.csv
  # ['bt', 'not', 'business', 'phone', 'email', 'get', 'would', 'no', 'new', 'number']
  # Cleaned_BT Forums Community.csv
  # ['bt', 'td', 'not', 'get', 'no', 'tr', 'would', 'up', 'new', 'now']
  # Cleaned_Orange TrustPilot Reviews.csv
  # ['orange', 'not', 'phone', 'customer', 'service', 'no', 'would', 'get', 'up', 'contract']
  # Cleaned_VirginMedia TrustPilot Reviews.csv
  # ['not', 'virgin', 'service', 'no', 'customer', 'get', 'up', 'would', 'internet', 'phone']
  # Cleaned_Vodafone Final Reviews.csv
  # ['not', 'vodafone', 'phone', 'customer', 'no', 'service', 'get', 'contract', 'told', 'would']
  # Cleaned_BT TrustPilot Reviews.csv
  # ['bt', 'not', 'no', 'service', 'would', 'up', 'get', 'phone', 'customer', 'told']

if Tables :
  MainPath = r'/content/drive/MyDrive/Data/PhD/Week 24 All Data'
  DataFiles = os.listdir(os.path.join(MainPath,'0 Data'))
  DataFiles = [i for i in DataFiles if i[0] =='C']

  for File in DataFiles : 
    data = pd.read_csv(os.path.join(MainPath ,'0 Data',File))
    print(File)
    Text = ' '.join([str(i) for i in data['CleanedText'].tolist()]).split()
    TextBG = [f'{Text[n]} {Text[n+1]}' for n in range(len(Text)-1)]
    print(list(pd.Series(TextBG).value_counts().index[:10]))


  # Cleaned_BTBusiness.csv
  # ['bt', 'not', 'business', 'phone', 'email', 'get', 'would', 'no', 'new', 'number']
  # Cleaned_BT Forums Community.csv
  # ['bt', 'td', 'not', 'get', 'no', 'tr', 'would', 'up', 'new', 'now']
  # Cleaned_Orange TrustPilot Reviews.csv
  # ['orange', 'not', 'phone', 'customer', 'service', 'no', 'would', 'get', 'up', 'contract']
  # Cleaned_VirginMedia TrustPilot Reviews.csv
  # ['not', 'virgin', 'service', 'no', 'customer', 'get', 'up', 'would', 'internet', 'phone']
  # Cleaned_Vodafone Final Reviews.csv
  # ['not', 'vodafone', 'phone', 'customer', 'no', 'service', 'get', 'contract', 'told', 'would']
  # Cleaned_BT TrustPilot Reviews.csv
  # ['bt', 'not', 'no', 'service', 'would', 'up', 'get', 'phone', 'customer', 'told']

TextBG[:10]

Text[:20]

Tables = True

if Tables :
  Round = 2
  Path = '/content/drive/MyDrive/Data/PhD/Week 24 All Data'
  Folders = [name for name in os.listdir(Path) if os.path.isdir(os.path.join(Path, name)) ]
  Folders = [i for i in Folders if i[0]!= '0']
  DataDict = {}
  for File in Folders :
    if os.path.exists(os.path.join(Path,File,'01 GSDMMFiles','Clusters Number 5.csv'))  : 
      data = pd.read_csv(os.path.join(Path,File,'01 GSDMMFiles','Clusters Number 5.csv'))
      print(f'For data {File}')
      Values = data['Loss'].tolist()
      # print(f'Min :  {np.round(np.min(Values),Round) } , Max  : {np.round(np.max(Values),Round)} , Mean  : {np.round(np.mean(Values),Round)} ,  SD  : {np.round(np.std(Values),Round)} ')
      print(f'{np.round(np.min(Values),Round) }& {np.round(np.max(Values),Round)}&{np.round(np.mean(Values),Round)}&{np.round(np.std(Values),Round)}')

if Tables :
  Slash = '\\' + '\\'
  Round = 2
  Path = '/content/drive/MyDrive/Data/PhD/Week 24 All Data/0 Data/_CombinedBestValues.csv'
  data = pd.read_csv(Path)
  for j in range(66) : 
    L = [np.round(i,2) if type(i)!=str else i for i in data.iloc[j,:].tolist()]
    L = [str(i) for i in L]
    print(' & '.join(L) + Slash )

if Tables :
  Slash = '\\' + '\\'
  Round = 2
  Path = '/content/drive/MyDrive/Data/PhD/Week 24 All Data/0 Data/_CombinedBestValuesStatistics.csv'
  data = pd.read_csv(Path)
  for j in range(4) : 
    L = [np.round(i,2) if type(i)!=str else i for i in data.iloc[j,:].tolist()]
    L = [str(i) for i in L]
    print(' & '.join(L) + Slash )



if Tables :
  Path = '/content/drive/MyDrive/Data/PhD/Week 24 All Data/SeveralClusters'
  Folders = [name for name in os.listdir(Path) if os.path.isdir(os.path.join(Path, name)) ]
  Folders = [i for i in Folders if i[0]!= '0']
  Data = pd.DataFrame()
  for File in Folders : 
    for Cluster in [3,5,10,15,20] : 
      data = pd.read_csv(os.path.join(Path,File,'06 Combined CFs',f'CombinedCFs{Cluster}.csv'))
      data['Dataset'] = File
      data['Clusters'] = Cluster
      Data = pd.concat([Data,data],axis=0)
      # print(Data.shape)

  #   DataDict[File] = {'Alpha':{},'Beta':{},'Range of CF':{},'SD of CF':{}}
  #   for Type in ['WBCV','AllBCV','MeanBCV','MinBCV','MaxBCV','CohBCV','EqualParameters_AllBCV','EqualParameters_MeanBCV','EqualParameters_MinBCV','EqualParameters_MaxBCV','EqualParameters_CohBCV'] : 
  #     DataDict[File]['Alpha'][Type] = data[data[Type] == data[Type].min()]['Alpha'].values[0]
  #     DataDict[File]['Beta'][Type] = data[data[Type] == data[Type].min()]['Beta'].values[0]
  #     DataDict[File]['Range of CF'][Type] = data[Type].max()-data[Type].min()
  #     DataDict[File]['SD of CF'][Type] = data[Type].std()
      

  # Round = 2
  # D = pd.DataFrame(DataDict['BTBusiness']) 
  # Slash = '\\' + '\\'
  # k=-1
  # k+=1
  # print(f"WCV (A=1, B=0) &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} {Slash}")
  # k+=1
  # print(f"AllBCV (A=0, B=1) &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} {Slash}")
  # k+=1
  # print(f"MeanBCV (A=0, B=1) &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} {Slash}")
  # k+=1
  # print(f"MinBCV (A=0, B=1)  &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} {Slash}")
  # k+=1
  # print(f"MaxBCV (A=0, B=1) &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} {Slash}")
  # k+=1
  # print(f"CohBCV (A=0, B=1)   &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} {Slash}")
  # k+=1
  # print(f"AllCF (A=B=1)  &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} {Slash}")
  # k+=1
  # print(f"MeanCF (A=B=1)  &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} {Slash}")
  # k+=1
  # print(f"MinCF (A=B=1)  &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} {Slash}")
  # k+=1
  # print(f"MaxCF (A=B=1)  &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} {Slash}")
  # k+=1
  # print(f"CohCF (A=B=1) &{np.round(D['Alpha'].tolist()[k],Round)}&{np.round(D['Beta'].tolist()[k],Round)}&{np.round(D['Range of CF'].tolist()[k],Round)}& {np.round(D['SD of CF'].tolist()[k],Round)} {Slash} [1ex] % [1ex] adds vertical space")
  Data.reset_index(inplace = True)
  Data.drop(['index','Unnamed: 0','Alpha','Beta'],axis=1,inplace = True)
  Data

Data

if Tables :
  Slash = '\\' + '\\'
  for N in range(6) : 
    D = Data[Data['Dataset']==Data['Dataset'].unique()[N]]
    print(Data['Dataset'].unique()[N])
    D.reset_index(inplace = True)
    D.drop(['index'],axis=1,inplace = True)
    for i in range(D.shape[0]) : 
      print(str(D.iloc[i,13])+ ' & ' + ' & '.join([str(np.round(j,2)) for j in D.iloc[i,:].tolist()[:12]]) + Slash )
    print('--------------------------------------')



import matplotlib.pyplot as plt

plt.rcParams.update({'font.size': 24})

Tables = True
if Tables : 
  Path = '/content/drive/MyDrive/Data/PhD/Week 24 All Data/0 Data'
  Files = [i for i in os.listdir(Path) if i[:7] == 'Cleaned']
  NumberOfWords = {}
  for File in Files : 
    data = pd.read_csv(os.path.join(Path,File))
    FileName = File.replace('Cleaned_','').replace('.csv','')
    DataDict[FileName] =data['WordLength'].tolist()



k=-1
k+=1
plt.figure(figsize = (20, 8))
plt.title(list(DataDict.keys())[k])
plt.xlabel('Number of Words')
plt.ylabel('Repetition')
plt.hist(DataDict[list(DataDict.keys())[k]], bins=60, alpha=0.7, histtype='bar')
plt.show()

k+=1
plt.figure(figsize = (20, 8))
plt.title(list(DataDict.keys())[k])
plt.xlabel('Number of Words')
plt.ylabel('Repetition')
plt.hist(DataDict[list(DataDict.keys())[k]], bins=60, alpha=0.7, histtype='bar')
plt.show()

k+=1
plt.figure(figsize = (20, 8))
plt.title(list(DataDict.keys())[k])
plt.xlabel('Number of Words')
plt.ylabel('Repetition')
plt.hist(DataDict[list(DataDict.keys())[k]], bins=60, alpha=0.7, histtype='bar')
plt.show()

k+=1
plt.figure(figsize = (20, 8))
plt.title(list(DataDict.keys())[k])
plt.xlabel('Number of Words')
plt.ylabel('Repetition')
plt.hist(DataDict[list(DataDict.keys())[k]], bins=60, alpha=0.7, histtype='bar')
plt.show()

k+=1
plt.figure(figsize = (20, 8))
plt.title(list(DataDict.keys())[k])
plt.xlabel('Number of Words')
plt.ylabel('Repetition')
plt.hist(DataDict[list(DataDict.keys())[k]], bins=60, alpha=0.7, histtype='bar')
plt.show()

k+=1
plt.figure(figsize = (20, 8))
plt.title(list(DataDict.keys())[k])
plt.xlabel('Number of Words')
plt.ylabel('Repetition')
plt.hist(DataDict[list(DataDict.keys())[k]], bins=60, alpha=0.7, histtype='bar')
plt.show()

Tables = True
import pandas as pd
import os
import numpy as np

List = [int(i) for i in data[data['Loss'] == data['Loss'].min()]['Doc Number'].values[0].strip('[]').split()]

Slash = '\\' + '\\'
if Tables :
  Path = '/content/drive/MyDrive/Data/PhD/Week 24 All Data'
  Folders = [name for name in os.listdir(Path) if os.path.isdir(os.path.join(Path, name)) ]
  Folders = [i for i in Folders if i[0]!= '0']
  for File in Folders : 
    ThisFile = os.path.join(Path,File,'01 GSDMMFiles','Clusters Number 5.csv')
    if os.path.exists(ThisFile) : 
      data = pd.read_csv(ThisFile)
      print(r'\hline ')
      print(str(File) + r'&  & & \\[0.5ex]')
      print(r' \hline')
      LeastLossWords = data[data['Loss'] == data['Loss'].min()]['Top Words'].values[0]
      List = [int(i) for i in data[data['Loss'] == data['Loss'].min()]['Doc Number'].values[0].strip('[]').split()]
      Sum = sum(List)
      AllWords = [i.split("'")[1::2] for i in LeastLossWords.split('\n')][1:]
      h = 0
      for i in AllWords : 
        h+=1
        print(f'Topic {h} & {str(",").join(i[:5])} & ** & {np.round(100*List[h-1]/Sum,2)}\\% {Slash}')
        if h == 5 : 
          print(f' & {str(",").join(i[5:])} & & {Slash} [0.5ex]')
        else : 
          print(f' & {str(",").join(i[5:])} & & {Slash} ')

# Slash = '\\' + '\\'
# if Tables :
#   Path = '/content/drive/MyDrive/Data/PhD/Week 24 All Data'
#   Folders = [name for name in os.listdir(Path) if os.path.isdir(os.path.join(Path, name)) ]
#   Folders = [i for i in Folders if i[0]!= '0']
#   for File in Folders : 
#     ThisFile = os.path.join(Path,File,'01 GSDMMFiles','Clusters Number 5.csv')
#     if os.path.exists(ThisFile) : 
#       data = pd.read_csv(ThisFile)
#       OnesWords = data[data['Parameters']=='[0.1, 0.1]']['Top Words'].values[0]
#       AllWords = [i.split("'")[1::2] for i in OnesWords.split('\n')][1:]
#       for i in AllWords : 
#         print(f'{File} & {str(",").join(i[:5])} & ** {Slash}')
#         print(f'- & {str(",").join(i[5:])} & - {Slash}')

Slash = '\\' + '\\'
if Tables :
  Path = '/content/drive/MyDrive/Data/PhD/Week 24 All Data'
  Folders = [name for name in os.listdir(Path) if os.path.isdir(os.path.join(Path, name)) ]
  Folders = [i for i in Folders if i[0]!= '0']
  for File in Folders : 
    ThisFile = os.path.join(Path,File,'01 GSDMMFiles','Clusters Number 5.csv')
    if os.path.exists(ThisFile) : 
      data = pd.read_csv(ThisFile)
      print(r'\hline ')
      print(str(File) + r'&  & & \\[0.5ex]')
      print(r' \hline')
      LeastLossWords = data[data['Parameters']=='[0.1, 0.1]']['Top Words'].values[0]
      List = [int(i) for i in data[data['Parameters']=='[0.1, 0.1]']['Doc Number'].values[0].strip('[]').split()]
      Sum = sum(List)
      AllWords = [i.split("'")[1::2] for i in LeastLossWords.split('\n')][1:]
      h = 0
      for i in AllWords : 
        h+=1
        print(f'Topic {h} & {str(",").join(i[:5])} & ** & {np.round(100*List[h-1]/Sum,2)}\\% {Slash}')
        if h == 5 : 
          print(f' & {str(",").join(i[5:])} & & {Slash} [0.5ex]')
        else : 
          print(f' & {str(",").join(i[5:])} & & {Slash} ')





# def (Clusters,ShowResults = True) : 
#   global GetAllWords,SavedWords
#   global EmptySentences,EmptySentencesIndex
  
#   ClustersDiffs = []
#   BetweenDiffs = []
#   if ShowResults : print('Calculating Within Clusters Variance')
#   for Cl in Clusters['Top Words'].split('Cluster')[1:] : 
#     AllWords = Cl.split("'")[1::2]
#     if len(AllWords) > 5 : 
#       Diffs = []
#       for i in range(len(AllWords)-1) : 
#         for j in range(i+1,len(AllWords)) : 
#           if AllWords[i] in SavedWords.keys() and AllWords[j] in SavedWords.keys() : 
#             Diffs.append(float(WordDifference(AllWords[i],AllWords[j])))
#           else : 
#             Diffs.append(0)
#       if len(Diffs) <= 1 : 
#         EmptySentencesIndex+=1
#         EmptySentences[EmptySentencesIndex] = ['AllWords_Within',Clusters]
#         print(f'Total Empty Sentence {EmptySentencesIndex}')
#       ClustersDiffs.append(np.mean(Diffs))

"""# 9) Several Clusters

## 9.1) Functions
"""

# MainPath

SeveralClusters =  True

if SeveralClusters : 
  MainPath,SelectedData = None,None
  def SCApplyGSDMM(K): 
    global MainPath,SelectedData
    if  os.path.exists(os.path.join(MainPath,SelectedData,'01 GSDMMFiles',f'Clusters Number {K}.csv')) :
      print(f'Cluster {K} Exists')
      return None
    print(f'Applying for Cluster {K}')
    tokens_reviews = list(sent_to_words(data['CleanedText']))
    tokens_reviews = make_n_grams(tokens_reviews)
    reviews_lemmatized = lemmatization(tokens_reviews, allowed_postags=['NOUN', 'VERB', 'ADV'])
    reviews_lemmatized = remove_stopwords(reviews_lemmatized)
    print(reviews_lemmatized)
    np.random.seed(0)
    Results =[]
    Alpha = 0.1
    Beta = 0.1
    mgp = MovieGroupProcess(K=K, alpha=Alpha, beta=Beta, n_iters=30)
    vocab = set(x for review in reviews_lemmatized for x in review)
    n_terms = len(vocab)
    model = mgp.fit(reviews_lemmatized, n_terms)
    doc_count = np.array(mgp.cluster_doc_count)
    top_index = doc_count.argsort()[-20:][::-1]
    Loss =0
    for i in range(K) : 
      Loss += abs((1/K)-(doc_count[i]/sum(doc_count)))
    Results.append({'Parameters' : [Alpha,Beta],
                    'Loss':Loss,
                    'Doc Number':doc_count,
                    'Top Index':doc_count.argsort()[-20:][::-1],
                    'Top Words' : top_words(mgp,mgp.cluster_word_distribution, top_index, 10)[0]})
    
    ResultsDF = pd.DataFrame(columns = ['Parameters', 'Loss', 'Doc Number', 'Top Index', 'Top Words'])
    for n,i in enumerate(Results) : 
      ResultsDF.loc[n] = list(i.values())
    if not os.path.exists(os.path.join(MainPath,'SeveralClusters')) :  os.makedirs(os.path.join(MainPath,SelectedData,'SeveralClusters'))
    if not os.path.exists(os.path.join(MainPath,'SeveralClusters',SelectedData)) :  os.makedirs(os.path.join(MainPath,SelectedData,'SeveralClusters',SelectedData))
    if not os.path.exists(os.path.join(MainPath,'SeveralClusters',SelectedData,'01 GSDMMFiles')) :  os.makedirs(os.path.join(MainPath,'SeveralClusters',SelectedData,'01 GSDMMFiles'))
    ResultsDF.to_csv(os.path.join(MainPath,'SeveralClusters',SelectedData,'01 GSDMMFiles',f'Clusters Number {K}.csv'))  # saving in 01 folder
    return Results



"""## 9.2) Reading Data

Read data files and other needed files
"""

if SeveralClusters : 
  MainPath = r'/content/drive/MyDrive/Data/PhD/Week 24 All Data'
  DataFiles = os.listdir(os.path.join(MainPath,'0 Data'))
  DataFiles = [i for i in DataFiles if i[0:7]=='Cleaned']
  print(DataFiles)

"""## 9.3) Applying GSDMM"""

if SeveralClusters : 
  for ThisData in tqdm(DataFiles) : 
    data = pd.read_csv(os.path.join(MainPath,'0 Data',ThisData))
    SelectedData= ThisData.split('.')[0].split('_')[1]
    for k in [3,5,10,15,20] : 
      SCApplyGSDMM(k)



if SeveralClusters : 
  Round = 2
  Path = '/content/drive/MyDrive/Data/PhD/Week 24 All Data/SeveralClusters'
  Folders = [name for name in os.listdir(Path) if os.path.isdir(os.path.join(Path, name)) ]
  Folders = [i for i in Folders if i[0]!= '0']
  DataDict = {}
  for File in Folders :
    DataDict[File] = {}
    for Cluster in os.listdir(os.path.join(Path,File,'01 GSDMMFiles')) : 
      C = Cluster.strip('.csv')
      data = pd.read_csv(os.path.join(Path,File,'01 GSDMMFiles',Cluster))
      for F in ['Parameters','Loss','Doc Number','Top Words'] : 
        DataDict[File][f'{C}_{F}'] = data[F][0]
  DataDict

if SeveralClusters : pd.DataFrame(DataDict).T.head()

if SeveralClusters : pd.DataFrame(DataDict).T.to_csv('/content/drive/MyDrive/Data/PhD/Week 24 All Data/0 Data/_ManyCusters.csv')

pd.DataFrame(DataDict).T





"""## 9.4) Apply CFs"""

# data = pd.read_csv('/content/drive/MyDrive/Data/PhD/Week 24 All Data/0 Data/_ManyCusters.csv')
# data.head()

# DataDict = {k:{i:{} for i in [3,5,10,15,20]} for k in data['Unnamed: 0'].tolist()}
# for i in [3,5,10,15,20] : 
#   for Type in data['Unnamed: 0'].tolist() : 
#     DataDict[Type][i] = [data[data['Unnamed: 0']==Type][f'Clusters Number {i}_Loss'].values[0],data[data['Unnamed: 0']==Type][f'Clusters Number {i}_Doc Number'].values[0],data[data['Unnamed: 0']==Type][f'Clusters Number {i}_Top Words'].values[0]]

# DataDict

if SeveralClusters : 
  EnglishWE = pd.read_csv(os.path.join(MainPath ,'0 Data','_AllWordsWE.csv'))
  EnglishWE.head()

if SeveralClusters : 
  EnglishWEDict = {}
  for i in range(EnglishWE.shape[0]) : 
    EnglishWEDict[EnglishWE['Word'][i]] = [EnglishWE[str(j)][i] for j in range(300)]

if SeveralClusters : 
  EnglishWE = pd.read_csv(os.path.join(MainPath ,'0 Data','_AllWordsWE.csv'))
  GetAllWords = []
  MainPath = '/content/drive/MyDrive/Data/PhD/Week 24 All Data/SeveralClusters'
  for SelectedData in ['Orange TrustPilot Reviews','BT Forums Community','BTBusiness','VirginMedia TrustPilot Reviews','Vodafone Final Reviews','BT TrustPilot Reviews'] : 
    for w in range(3,21) : 
      ThisFile =os.path.join(MainPath,SelectedData,'01 GSDMMFiles',f'Clusters Number {w}.csv')
      

      if os.path.exists(ThisFile) : 
        ResultsData = pd.read_csv(ThisFile)  
        # for i in range(w) : 
        #   ResultsData[f'Cluster {i}'] = ResultsData[f'Cluster {i}'].apply(lambda x :  ClusterClean(x))
        for i in ResultsData['Top Words'].tolist() : 
          for j in i.split('Cluster')[1:] : 
            GetAllWords.extend(j.split("'")[1::2]) 
  print(f'\nTotal Number of Unique Words {str(len(set(GetAllWords)))}')
  p = 0
  for i in set(GetAllWords) : 
    if i in EnglishWEDict.keys() : 
      p+=1
  print(f'Number of Exist Words is {p} and Percentage of Words Exists in English Words {100*np.round(p/len(set(GetAllWords)),3)} %')
  SavedWords = {}
  for word in GetAllWords : 
    if word in EnglishWEDict.keys() : 
      SavedWords[word] = EnglishWEDict[word]
  print(f'Number of Words in SavedWords {len(list(SavedWords.keys()))} ')

if SeveralClusters : 
  MainPath = '/content/drive/MyDrive/Data/PhD/Week 24 All Data/SeveralClusters'
  for SelectedData in ['Orange TrustPilot Reviews','BT Forums Community','BTBusiness','VirginMedia TrustPilot Reviews','Vodafone Final Reviews','BT TrustPilot Reviews'] : 
    for w in range(3,21) : 
      ThisFile = os.path.join(MainPath,SelectedData,'01 GSDMMFiles',f'Clusters Number {w}.csv')

      if os.path.exists(ThisFile) : 
        ResultsData = pd.read_csv(ThisFile)  
        ResultsData['Parameters'] = ResultsData['Parameters'].apply(lambda x : [float(i) for i in x.strip('[]').split(',')])
        ResultsData['Doc Number'] = ResultsData['Doc Number'].apply(lambda x : [int(i) for i in x.strip('[]').split()])
        ResultsData['Top Index'] = ResultsData['Top Index'].apply(lambda x : [int(i) for i in x.strip('[]').split()])
        Losses = ResultsData['Loss'].tolist()
        Losses.sort()
        Losses = ResultsData['Loss'].tolist()
        Losses.sort()

        SortedResults = []
        for Loss in Losses : 
          for i in range(ResultsData.shape[0]) :
            if Loss ==ResultsData['Loss'][i] : 
              SortedResults.append({k:v for k,v in zip(list(ResultsData.keys()),[ResultsData[j][i] for j in list(ResultsData.keys())])})

        for i in tqdm (range(len(SortedResults))) : 
          for Cl in SortedResults[i]['Top Words'].split('Cluster')[1:] : 
            AllWords = Cl.split("'")[1::2]
        
        CostFunctionResults = {}
        for i in tqdm (range(len(SortedResults))) : 
          ThisClusterValue = list(ClustersCostFunctionAllWords(SortedResults[i],ShowResults=False))
          CostFunctionResults[i] = {'AllBCV':ThisClusterValue[0],'AllWCV':ThisClusterValue[1]}
      
        for i in tqdm (range(len(SortedResults))) : 
          ThisClusterValue = list(ClustersCostFunctionMean(SortedResults[i],ShowResults=False))
          CostFunctionResults[i]['MeanBCV'] = ThisClusterValue[0]
          CostFunctionResults[i]['MeanWCV'] = ThisClusterValue[1]
      
        for i in tqdm (range(len(SortedResults))) : 
          ThisClusterValue = list(ClustersCostFunctionMin(SortedResults[i],ShowResults=False))
          CostFunctionResults[i]['MinBCV'] = ThisClusterValue[0]
          CostFunctionResults[i]['MinWCV'] = ThisClusterValue[1]

        for i in tqdm (range(len(SortedResults))) : 
          ThisClusterValue = list(ClustersCostFunctionMax(SortedResults[i],ShowResults=False))
          CostFunctionResults[i]['MaxBCV'] = ThisClusterValue[0]
          CostFunctionResults[i]['MaxWCV'] = ThisClusterValue[1]
          CostFunctionResults[i]['CohBCV'] = ClustersCostFunctionCoherence(SortedResults[i],ShowResults=False)


        for i in tqdm(CostFunctionResults.keys()): 
          AllBCV =  CostFunctionResults[i]['AllBCV']
          AllWCV =  CostFunctionResults[i]['AllWCV']
          MeanBCV =  CostFunctionResults[i]['MeanBCV']
          MinBCV =  CostFunctionResults[i]['MinBCV']
          MaxBCV =  CostFunctionResults[i]['MaxBCV']    
          CohBCV = CostFunctionResults[i]['CohBCV']                 

          ThisAllD,ThisMeanD,ThisMinD,ThisMaxD,ThisCohD = {},{},{},{},{}
          l=0
          for a in np.linspace(0.01, 1, num=5) : 
            for b in np.linspace(0.01, 1, num=5): 
              l+=1
              ThisAllD[l] = [a,b,float(a*float(AllWCV)) - float(b*float(AllBCV))]
              ThisMeanD[l] = [a,b,float(a*float(AllWCV)) - float(b*float(MeanBCV))]
              ThisMinD[l] = [a,b,float(a*float(AllWCV)) - float(b*float(MinBCV))]
              ThisMaxD[l] = [a,b,float(a*float(AllWCV)) - float(b*float(MaxBCV))]
              ThisCohD[l] = [a,b,float(a*float(AllWCV)) - float(b*float(CohBCV))]
          CostFunctionResults[i]['AllCF'] = ThisAllD
          CostFunctionResults[i]['MeanCF'] = ThisMeanD
          CostFunctionResults[i]['MinCF'] = ThisMinD
          CostFunctionResults[i]['MaxCF'] = ThisMaxD
          CostFunctionResults[i]['CohCF'] = ThisCohD
        for i in range(len(SortedResults)) : 
          for Item in ['AllBCV','AllWCV','MeanBCV','MinWCV','MaxBCV','MeanWCV','MinBCV','MaxWCV','CohBCV','AllCF','MeanCF','MinCF','MaxCF','CohCF'] : 
            SortedResults[i][Item] = CostFunctionResults[i][Item]

        Alpha,Beta,A,B,AllBCV,MeanBCV,MinBCV,MaxBCV,CohBCV,WCV,IDs,AllCF,MeanCF,MinCF,MaxCF,CohCF = [],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]
        n=0
        for i in SortedResults : 
          for k in i['MeanCF'].values() : 
            MeanCF.append(k[2])
          for k in i['MinCF'].values() : 
            MinCF.append(k[2])
          for k in i['MaxCF'].values() : 
            MaxCF.append(k[2])      
          for k in i['CohCF'].values() : 
            CohCF.append(k[2])      
          for j,k in i['AllCF'].items() : 
            n+=1
            IDs.append(n)
            AllCF.append(k[2])
            AllBCV.append(i['AllBCV'])
            MeanBCV.append(i['MeanBCV'])
            MinBCV.append(i['MinBCV'])
            MaxBCV.append(i['MaxBCV'])
            CohBCV.append(i['CohBCV'])
            WCV.append(i['AllWCV'])
            A.append(k[0])
            B.append(k[1])
            Alpha.append(i['Parameters'][0])
            Beta.append(i['Parameters'][1])

        ResultsDF = pd.DataFrame(list(zip(IDs,Alpha,Beta,A,B,WCV,AllBCV,AllCF,MeanBCV,MeanCF,MinBCV,MinCF,MaxBCV,MaxCF,CohBCV,CohCF)),columns = ['IDs','Alpha','Beta','A','B','WCV','AllBCV','AllCF','MeanBCV','MeanCF','MinBCV','MinCF','MaxBCV','MaxCF','CohBCV','CohCF'])
        if not os.path.exists(os.path.join(MainPath,SelectedData,'02 Result DF'))  :  os.makedirs(os.path.join(MainPath,SelectedData,'02 Result DF'))
        ResultsDF.to_csv(os.path.join(MainPath,SelectedData,'02 Result DF' ,f'ResultsDF{w}.csv'))

MainPath

if SeveralClusters : 
  for SelectedData in ['Orange TrustPilot Reviews','BT Forums Community','BTBusiness','VirginMedia TrustPilot Reviews','Vodafone Final Reviews','BT TrustPilot Reviews'] : 
    for w in range(3,21) : 
      ThisFile = os.path.join(MainPath,SelectedData,'02 Result DF' ,f'ResultsDF{w}.csv')
      if not os.path.exists(os.path.join(MainPath,SelectedData,'03 Best Values')) :  os.makedirs(os.path.join(MainPath,SelectedData,'03 Best Values'))
      if os.path.exists(ThisFile) : 
        ResultsDF = pd.read_csv(ThisFile) 
        if 'index' in ResultsDF.columns : ResultsDF.drop(['index'],axis=1,inplace=True)
        if 'Unnamed: 0' in ResultsDF.columns : ResultsDF.drop(['Unnamed: 0'],axis=1,inplace=True)
        CalculatedCFs = ['AllCF','MeanCF','MinCF','MaxCF','CohCF']
        CFsDataFrame = pd.DataFrame()
        for CF in CalculatedCFs : 
          ResultLists = []
          for A in ResultsDF['A'].unique() : 
            for B in ResultsDF['B'].unique() : 
              MinCF = ResultsDF[ResultsDF['A'] == A][ResultsDF['B'] == B][CF].min()
              ThisList = ResultsDF[ResultsDF[CF] == MinCF].iloc[0,:].tolist()
              ResultLists.append([ThisList[0]] + ThisList[3:5]+ThisList[1:3]+ThisList[5:])
          col_names = ['Trial Number','A','B','Alpha','Beta','WCV','AllBCV','AllCF','MeanBCV','MeanCF','MinBCV','MinCF','MaxBCV','MaxCF','CohBCV','CohCF']
          
          ThisCFsDataFrame = pd.DataFrame(ResultLists, columns=col_names)
          ThisCFsDataFrame['SelectedCF'] = CF
          print(tabulate(ResultLists, headers=col_names, tablefmt="fancy_grid"))
          CFsDataFrame = pd.concat([CFsDataFrame,ThisCFsDataFrame],axis=0)
        CFsDataFrame.to_csv(os.path.join(MainPath,SelectedData,'03 Best Values',f'BestCFValue{w}.csv'))

if SeveralClusters : 
  for SelectedData in ['Orange TrustPilot Reviews','BT Forums Community','BTBusiness','VirginMedia TrustPilot Reviews','Vodafone Final Reviews','BT TrustPilot Reviews'] : 
    Paths = [os.path.join(MainPath,SelectedData,'02 Result DF')  ,os.path.join(MainPath,SelectedData,'03 Best Values')]



    for Path in Paths : 
      if len(Path) > 1 : 
        for File in os.listdir(Path) : 
          ThisFile = os.path.join(Path,File)
          data = pd.read_csv(ThisFile)
          print(f'for file {File} Number of Nulss is {set(data.isna().sum().values)}')



"""## 9.5) Evaluation Methods"""

MainPath = '/content/drive/MyDrive/Data/PhD/Week 24 All Data/SeveralClusters'
SeveralClusters = True
import pandas as pd
import os

if SeveralClusters : 
  for SelectedData in ['Orange TrustPilot Reviews','BT Forums Community','BTBusiness','VirginMedia TrustPilot Reviews','Vodafone Final Reviews','BT TrustPilot Reviews'] : 
    for w in range(3,21) : 
      ThisFile =os.path.join(MainPath,SelectedData,'02 Result DF',f'ResultsDF{w}.csv')
      if os.path.exists(ThisFile) : 
        data = pd.read_csv(ThisFile)  
        print(f'for clutser {w} shape is  {data.shape}')
        for alpha in data['Alpha'].unique() : 
          for beta in data['Beta'].unique() : 
            if len(data[data['Alpha']==alpha][data['Beta']==beta]['AllBCV'].unique()) !=1 : print('error')
            if len(data[data['Alpha']==alpha][data['Beta']==beta]['MeanBCV'].unique()) !=1 : print('error')
            if len(data[data['Alpha']==alpha][data['Beta']==beta]['MinBCV'].unique()) !=1 : print('error')
            if len(data[data['Alpha']==alpha][data['Beta']==beta]['MaxBCV'].unique()) !=1 : print('error')
            if len(data[data['Alpha']==alpha][data['Beta']==beta]['WCV'].unique()) !=1 : print('error')

        AllBCVDict = {}
        n=0
        for alpha in data['Alpha'].unique() : 
          for beta in data['Beta'].unique() : 
            n+=1
            AllBCVDict[n] = {'Alpha': alpha,
                            'Beta':beta,
                            'AllBCV':data[data['Alpha']==alpha][data['Beta']==beta]['AllBCV'].unique()[0],
                            'MeanBCV':data[data['Alpha']==alpha][data['Beta']==beta]['MeanBCV'].unique()[0],
                            'MinBCV':data[data['Alpha']==alpha][data['Beta']==beta]['MinBCV'].unique()[0],
                            'MaxBCV':data[data['Alpha']==alpha][data['Beta']==beta]['MaxBCV'].unique()[0],
                            'WBCV':data[data['Alpha']==alpha][data['Beta']==beta]['WCV'].unique()[0],
                            'CohBCV':data[data['Alpha']==alpha][data['Beta']==beta]['CohBCV'].unique()[0],
                            'EqualParameters_AllBCV' : data[data['Alpha']==alpha][data['Beta']==beta]['WCV'].unique()[0] -data[data['Alpha']==alpha][data['Beta']==beta]['AllBCV'].unique()[0],
                            'EqualParameters_MeanBCV' : data[data['Alpha']==alpha][data['Beta']==beta]['WCV'].unique()[0] -data[data['Alpha']==alpha][data['Beta']==beta]['MeanBCV'].unique()[0],
                            'EqualParameters_MinBCV' : data[data['Alpha']==alpha][data['Beta']==beta]['WCV'].unique()[0] -data[data['Alpha']==alpha][data['Beta']==beta]['MinBCV'].unique()[0],
                            'EqualParameters_MaxBCV' : data[data['Alpha']==alpha][data['Beta']==beta]['WCV'].unique()[0] -data[data['Alpha']==alpha][data['Beta']==beta]['MaxBCV'].unique()[0],
                            'EqualParameters_CohBCV' : data[data['Alpha']==alpha][data['Beta']==beta]['WCV'].unique()[0] -data[data['Alpha']==alpha][data['Beta']==beta]['CohBCV'].unique()[0]}
        data = pd.DataFrame(AllBCVDict).T
        data.fillna(99,inplace=True)
        data['MincF'] = data.apply(lambda x : min(x.AllBCV,x.MeanBCV,x.MinBCV,x.MaxBCV,x.WBCV,x.CohBCV,x.EqualParameters_AllBCV,x.EqualParameters_MeanBCV,x.EqualParameters_MinBCV,x.EqualParameters_MaxBCV,x.EqualParameters_CohBCV),axis=1)
        data = data.sort_values(['Alpha', 'Beta'],ascending = [True, True])

        if not os.path.exists(os.path.join(MainPath,SelectedData, '06 Combined CFs')) :  os.makedirs(os.path.join(MainPath,SelectedData, '06 Combined CFs'))
        data.to_csv(os.path.join(MainPath,SelectedData, '06 Combined CFs',f'CombinedCFs{w}.csv'))

if SeveralClusters : 
  MinCFDict = {}
  for SelectedData in ['Orange TrustPilot Reviews','BT Forums Community','BTBusiness','VirginMedia TrustPilot Reviews','Vodafone Final Reviews','BT TrustPilot Reviews'] : 
    MinCFDict[SelectedData] = {}
    for w in [3,5,10,15,20] : 
      ThisFile = os.path.join(MainPath,SelectedData,'06 Combined CFs' ,f'CombinedCFs{w}.csv')
      if os.path.exists(ThisFile) : 
        ResultsDF = pd.read_csv(ThisFile) 
        print(ResultsDF.shape)
        MinCFDict[SelectedData][w] = ResultsDF['MincF'][0]
  MinCFDict

MinCFDict[Type].values()

MinCFDict[Type].values()

plt.rcParams.update({'font.size': 18})

if SeveralClusters : 
  plt.figure(figsize = (20, 8))
  plt.title('All Data')
  plt.xlabel('Clusters')
  plt.ylabel('Min CF Value')

  for Type in MinCFDict.keys() : 
    plt.plot([3,5,10,15,20],list(MinCFDict[Type].values()),linewidth=1,alpha=0.5,linestyle = 'solid',label = Type) 

  plt.xticks([3,5,10,15,20])
  plt.legend()
  plt.show()

SeveralClusters= True

if SeveralClusters : 
  MinCFDict = {}
  for SelectedData in ['Orange TrustPilot Reviews','BT Forums Community','BTBusiness','VirginMedia TrustPilot Reviews','Vodafone Final Reviews','BT TrustPilot Reviews'] : 
    MinCFDict[SelectedData] = {}
    for Type in ['WCV','AllBCV', 'AllCF', 'MeanBCV', 'MeanCF', 'MinBCV', 'MinCF', 'MaxBCV','MaxCF', 'CohBCV', 'CohCF'] : 
      MinCFDict[SelectedData][Type] = {}
      for w in [3,5,10,15,20] : 
        ThisFile = os.path.join(MainPath,SelectedData,'03 Best Values' ,f'BestCFValue{w}.csv')
        if os.path.exists(ThisFile) : 
          ResultsDF = pd.read_csv(ThisFile) 
          # print(ResultsDF.head())
          MinCFDict[SelectedData][Type][w] = ResultsDF[Type].min()
          
  MinCFDict

if SeveralClusters :  MinCFDict.keys()

k=-1
k+=1
ThisData = MinCFDict[list(MinCFDict.keys())[k]]
ThisData

k=-1
k+=1
ThisData = MinCFDict[list(MinCFDict.keys())[k]]
plt.figure(figsize = (20, 8))
plt.title(list(MinCFDict.keys())[k])
plt.xlabel('Clusters')
plt.ylabel('Min CF Value')

for Type in ThisData.keys() : 
  if 'CF' in str(Type) : 
    plt.plot([3,5,10,15,20],list(ThisData[Type].values()),linewidth=1,alpha=0.5,linestyle = 'solid',label = Type) 

plt.xticks([3,5,10,15,20])
plt.legend()
plt.show()

k+=1
ThisData = MinCFDict[list(MinCFDict.keys())[k]]
plt.figure(figsize = (20, 8))
plt.title(list(MinCFDict.keys())[k])
plt.xlabel('Clusters')
plt.ylabel('Min CF Value')

for Type in ThisData.keys() : 
  if 'CF' in str(Type) : 
    plt.plot([3,5,10,15,20],list(ThisData[Type].values()),linewidth=1,alpha=0.5,linestyle = 'solid',label = Type) 

plt.xticks([3,5,10,15,20])
plt.legend()
plt.show()

k+=1
ThisData = MinCFDict[list(MinCFDict.keys())[k]]
plt.figure(figsize = (20, 8))
plt.title(list(MinCFDict.keys())[k])
plt.xlabel('Clusters')
plt.ylabel('Min CF Value')

for Type in ThisData.keys() : 
  if 'CF' in str(Type) : 
    plt.plot([3,5,10,15,20],list(ThisData[Type].values()),linewidth=1,alpha=0.5,linestyle = 'solid',label = Type) 

plt.xticks([3,5,10,15,20])
plt.legend()
plt.show()

k+=1
ThisData = MinCFDict[list(MinCFDict.keys())[k]]
plt.figure(figsize = (20, 8))
plt.title(list(MinCFDict.keys())[k])
plt.xlabel('Clusters')
plt.ylabel('Min CF Value')

for Type in ThisData.keys() : 
  if 'CF' in str(Type) : 
    plt.plot([3,5,10,15,20],list(ThisData[Type].values()),linewidth=1,alpha=0.5,linestyle = 'solid',label = Type) 

plt.xticks([3,5,10,15,20])
plt.legend()
plt.show()

k+=1
ThisData = MinCFDict[list(MinCFDict.keys())[k]]
plt.figure(figsize = (20, 8))
plt.title(list(MinCFDict.keys())[k])
plt.xlabel('Clusters')
plt.ylabel('Min CF Value')

for Type in ThisData.keys() : 
  if 'CF' in str(Type) : 
    plt.plot([3,5,10,15,20],list(ThisData[Type].values()),linewidth=1,alpha=0.5,linestyle = 'solid',label = Type) 

plt.xticks([3,5,10,15,20])
plt.legend()
plt.show()

k+=1
ThisData = MinCFDict[list(MinCFDict.keys())[k]]
plt.figure(figsize = (20, 8))
plt.title(list(MinCFDict.keys())[k])
plt.xlabel('Clusters')
plt.ylabel('Min CF Value')

for Type in ThisData.keys() : 
  if 'CF' in str(Type) : 
    plt.plot([3,5,10,15,20],list(ThisData[Type].values()),linewidth=1,alpha=0.5,linestyle = 'solid',label = Type) 

plt.xticks([3,5,10,15,20])
plt.legend()
plt.show()

